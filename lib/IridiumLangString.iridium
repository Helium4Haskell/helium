module IridiumLangString
import ()

declare @putchar[1]: { !Int -> Int } {} [callconvention:c]

#[decl @kind [bytes "* -> *"]]
custom @"[]": @data

#[decl @kind [bytes "* -> *"]]
data @"[]" {
  #[link @"[]" @data]
  constructor @"[]": { forall a. [a] }

  #[link @"[]" @data]
  constructor @":": { forall a. a -> [a] -> [a] }
}

export_as @_$helium_runtime_unpack_string define @_$helium_runtime_unpack_string(%length: !Int, %pointer: !$UnsafePtr): ([Char]) {
unpack.entry:
  case %length: !Int int (0 to unpack.nil) otherwise unpack.cons
unpack.cons:
  %1 = literal int 1
  %length_minus_one = prim int_sub(%length: !Int, %1: !Int)
  %c = prim unsafeptr_read32(%pointer: !$UnsafePtr)
  %4 = literal int 4
  %pointer_plus_four = prim unsafeptr_add(%pointer: !$UnsafePtr, %4: !Int)
  %tail = call @_$helium_runtime_unpack_string[2]: (!Int -> !$UnsafePtr -> [Char]) $ (%length_minus_one: !Int, %pointer_plus_four: !$UnsafePtr)
  %tail_as_any = castthunk %tail: ![Char]
  %c_char = prim int_to_char(%c: !Int)
  %c_as_any = castthunk %c_char: !Char
  letalloc %list = constructor @":": (forall a. a -> [a] -> [a]) $ ({Char}, %c_as_any: Char, %tail_as_any: [Char])
  return %list: ![Char]
unpack.nil:
  letalloc %nil = constructor @"[]": (forall a. [a]) $ ({Char})
  return %nil: ![Char]
}

export_as @_$helium_runtime_print_string define @_$helium_runtime_print_string(%arg_list: ![Char]): Int {
print.entry:
  %0 = literal int 0
  jump print.loop

print.loop:
  ; %res is always zero, but we need it to prevent the removal of the @putchar functions.
  ; variable %_ will remain live, by the `seq` instruction and will thus not be removed by
  ; a dead code analysis
  %res = phi (print.entry => %0: !Int, print.cons => %res_cons: !Int)
  %list = phi (print.entry => %arg_list: ![Char], print.cons => %cons: ![Char])
  case %list: ![Char] constructor (@"[]": (forall a. [a]) to print.nil, @":": (forall a. a -> [a] -> [a]) to print.cons)

print.nil:
  return %res: !Int

print.cons:
  match %list: ![Char] on @":": (forall a. a -> [a] -> [a]) {Char} (%c_thunk, %cons_as_any)
  %c_whnf = eval %c_thunk: Char
  %c = prim char_to_int(%c_whnf: !Char)
  %c2 = seq %res: !Int, %c: !Int ; Prevent reordering of @putchar calls
  %_ = call @putchar[1]: (!Int -> Int) $ (%c2: !Int)
  %cons = eval %cons_as_any: [Char]
  %res_cons = seq %_: !Int, %res: !Int
  jump print.loop
}

declare @exit[1]: { !Int -> Int } {} [callconvention:c]

export_as @_$helium_runtime_error define @_$helium_runtime_error(forall a, %msg: [Char]): a {
error.entry:
  %msg_list = eval %msg: [Char]
  %_1 = call @_$helium_runtime_print_string[1]: (![Char] -> Int) $ (%msg_list: ![Char])
  %1 = literal int 1
  %_2 = call @exit[1]: (!Int -> Int) $ (%1: !Int)
  unreachable
}
