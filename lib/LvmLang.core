----------------------------------------------------------------
-- Daan Leijen (c) 2001
--
-- $Revision$
-- $Author$
-- $Date$
----------------------------------------------------------------
module LvmLang where

import ( IridiumLang )

{----------------------------------------------------------
  Basic data types
----------------------------------------------------------}


-- data '':[]'' v$0 = '':[]'' | (:) v$0 [v$0]
-- data '':()''    = '':()''

{----------------------------------------------------------
  Type definitions
----------------------------------------------------------}
type Double       = Float

type PackedString = String 

{----------------------------------------------------------
  Strictness
----------------------------------------------------------}
($!) :: forall v$0. forall v$1. (v$0 -> v$1) -> v$0 -> v$1
($!) : export = forall v$0. forall v$1. \ !f: (v$0 -> v$1) -> \ !x: v$0 -> f x

{----------------------------------------------------------
  Basic arithmetic on Int's
----------------------------------------------------------}
(+#) :: Int -> Int -> Int
(+#) : export = \ !x: Int -> \ !y: Int -> primAddInt x y

(-#) :: Int -> Int -> Int
(-#) : export = \ !x: Int -> \ !y: Int -> primSubInt x y

(*#) :: Int -> Int -> Int
(*#) : export = \ !x: Int -> \ !y: Int -> primMulInt x y

-- TODO: Round to -inf instead of zero
div :: Int -> Int -> Int
div : export = \ !x: Int -> \ !y: Int -> quot x y -- primDivInt x y

-- TODO: Round to -inf instead of zero
mod :: Int -> Int -> Int
mod : export = \ !x: Int -> \ !y: Int -> rem x y -- primModInt x y

quot :: Int -> Int -> Int
quot : export = \ !x: Int -> \ !y: Int -> primQuotInt x y

rem :: Int -> Int -> Int
rem : export = \ !x: Int -> \ !y: Int -> primRemInt x y
{-
and :: Int -> Int -> Int
and = \x: Int -> \y: Int -> primAndInt x y

xor :: Int -> Int -> Int
xor = \x: Int -> \y: Int -> primXorInt x y

or :: Int -> Int -> Int
or = \x: Int -> \y: Int -> primOrInt x y
-}
shr :: Int -> Int -> Int
shr : export = \ !x: Int -> \ !y: Int -> primShrInt x y

shl :: Int -> Int -> Int
shl : export = \ !x: Int -> \ !y: Int -> primShlInt x y

shrNat :: Int -> Int -> Int
shrNat : export = \ !x: Int -> \ !y: Int -> primShrNat x y

negInt :: Int -> Int
negInt : export = \ !x: Int -> primNegInt x

{----------------------------------------------------------
  Comparisons on Int's
----------------------------------------------------------}
(==#) :: Int -> Int -> Bool
(==#) : export = \ !x: Int -> \ !y: Int -> primEqInt x y

(/=#) :: Int -> Int -> Bool
(/=#) : export = \ !x: Int -> \ !y: Int -> primNeInt x y

(<#) :: Int -> Int -> Bool
(<#) : export = \ !x: Int -> \ !y: Int -> primLtInt x y

(>#) :: Int -> Int -> Bool
(>#) : export = \ !x: Int -> \ !y: Int -> primGtInt x y

(<=#) :: Int -> Int -> Bool
(<=#) : export = \ !x: Int -> \ !y: Int -> primLeInt x y

(>=#) :: Int -> Int -> Bool
(>=#) : export = \ !x: Int -> \ !y: Int -> primGeInt x y

{----------------------------------------------------------
  Basic arithmetic on Float's
----------------------------------------------------------}

(+.) :: Float -> Float -> Float
(+.) : export = \x: Float -> \y: Float -> primAddFloat x y

(-.) :: Float -> Float -> Float
(-.) : export = \x: Float -> \y: Float -> primSubFloat x y

(*.) :: Float -> Float -> Float
(*.) : export = \x: Float -> \y: Float -> primMulFloat x y

(/.) :: Float -> Float -> Float
(/.) : export = \x: Float -> \y: Float -> primDivFloat x y

negFloat :: Float -> Float
negFloat : export = \x: Float -> primNegFloat x

{----------------------------------------------------------
  Comparisons on Float's
----------------------------------------------------------}

(==.) :: Float -> Float -> Bool
(==.) : export = \x: Float -> \y: Float -> primEqFloat x y

(/=.) :: Float -> Float -> Bool
(/=.) : export = \x: Float -> \y: Float -> primNeFloat x y

(<.) :: Float -> Float -> Bool
(<.) : export = \x: Float -> \y: Float -> primLtFloat x y

(>.) :: Float -> Float -> Bool
(>.) : export = \x: Float -> \y: Float -> primGtFloat x y

(<=.) :: Float -> Float -> Bool
(<=.) : export = \x: Float -> \y: Float -> primLeFloat x y

(>=.) :: Float -> Float -> Bool
(>=.) : export = \x: Float -> \y: Float -> primGeFloat x y

{----------------------------------------------------------
  Packed strings
----------------------------------------------------------}
stringFromPacked :: PackedString -> String
stringFromPacked : export = \p: String -> p

packedFromString :: String -> PackedString
packedFromString : export = \s: String -> s
  {- = let forced s = case s of
                     []       -> []
                     (:) x xs -> let! y  = x
                                      ys = forced xs
                                 in (:) y ys
        length n s = case s of
                       []       -> n
                       (:) x xs -> let! m = (+#) n 1
                                   in length m xs
    in let! fs  = forced s
            len = length 0 fs
       in prim_string_of_chars len fs -}
            
  
    {-
    let forceLength n xs = case xs of
                             (:) x xx -> seq x (forceLength ((+#) n 1) xx)
                             []       -> n 
    in let! len = forceLength 0 s 
            t   = s 
       in prim_string_of_chars len t
    -}

{- packedLength :: PackedString -> Int
packedLength s
  = let! s = s in prim_string_length s
-}
{----------------------------------------------------------
  List helpers
----------------------------------------------------------}
{-
length :: [a] -> Int
length xs
  = foldlStrict (+#) 0 xs

foldlStrict :: (b -> a -> b) -> b -> [a] -> b
foldlStrict f z xs
  = case xs of
      (:) x xx -> case f z x of
                    z -> foldlStrict f z xx
      []       -> z
-}