module IridiumLangEval
import ()

#[decl @kind [bytes "* -> *"]]
custom @"[]": @data

#[decl @kind [bytes "* -> *"]]
data @"[]" {
  #[link @"[]" @data]
  constructor @"[]": { forall a. [a] } <>

  #[link @"[]" @data]
  constructor @":": { forall a. a -> [a] -> [a] } <>
}

export_as @_$helium_runtime_eval define @_$helium_runtime_eval(%a: !$UnsafePtr, %b: !Int): !$UnsafePtr {
eval.entry:
  case %b: !Int int ( 0 to eval.thunk) otherwise eval.whnf

eval.whnf:
  return %a: !$UnsafePtr

eval.thunk:
  %res = call @eval_thunk[1]: (!$UnsafePtr -> $UnsafePtr) $ (%a: !$UnsafeThunk)
  return %res: !$UnsafePtr
}

declare @LvmException.error[1]: { forall a. [Char] -> a }
; Uncomment the declaration and calls to trace_thunk_eval and trace_thunk_done to debug thunk evaluation.
; declare @trace_thunk_eval[1]: { !$UnsafePtr -> Int }
; declare @trace_thunk_done[1]: { !$UnsafePtr -> Int }

export_as @eval_thunk define @eval_thunk(%a: !$UnsafePtr): $UnsafePtr {
entry:
  %remaining = prim thunk_extract_remaining(%a: !$UnsafePtr)
  %given = prim thunk_extract_given(%a: !$UnsafePtr)
  ; %debug = call @trace_thunk_eval[1]: ( !$UnsafePtr -> Int ) $ (%a: !$UnsafePtr)

  %remaining_int = prim int16_sext_to_int(%remaining: !Int16)

  case %remaining_int: !Int int ( 32767 to is_blackhole, 32766 to is_evaluated) otherwise evaluate

is_blackhole:
  %err_loop = literal str "Loop blackhole\n"
  %err_loop_thunk = castthunk %err_loop: (![Char])
  %_call = call @LvmException.error[1]: (forall a. [Char] -> a) $ ({ () }, %err_loop_thunk: [Char])
  unreachable

is_evaluated:
  %evaluated_value = prim thunk_extract_value(%a: !$UnsafePtr)
  return %evaluated_value: !$UnsafePtr

evaluate:
  %type = prim thunk_get_type(%remaining: !Int16, %given: !Int16)

  case %type: !Int int ( 0 to unsaturated, 1 to saturated, 2 to oversaturated_self ) otherwise oversaturated_target

unsaturated:
  ; Thunk is an unsaturated function. It is already in WHNF
  return %a: !$UnsafePtr

saturated:
  ; Thunk is exactly saturated
  %saturated_value = prim thunk_eval(%a: !$UnsafePtr, %given: !Int16)
  ; %debug2 = call @trace_thunk_done[1]: ( !$UnsafePtr -> Int ) $ (%a: !$UnsafePtr)
  return %saturated_value: !$UnsafePtr

oversaturated_self:
  ; Thunk is oversaturated, but the target (if it exists) is not saturated.
  ; The evaluation must thus start at this thunk.

  %new_given = prim int16_neg(%remaining: !Int16)
  %oversaturated_given = prim int16_add(%given: !Int16, %remaining: !Int16)
  %o_target = prim thunk_eval_oversaturated_self(%a: !$UnsafePtr, %oversaturated_given: !Int16, %new_given: !Int16)

  %o_target_remaining = prim thunk_extract_remaining(%o_target: !$UnsafePtr)

  ; Compute values for the new thunk object
  %new_header = literal int 0
  ; new_remaining = o_target_remaining - new_given
  %minus_new_given = prim int16_neg(%new_given: !Int16)
  %new_remaining = prim int16_add(%o_target_remaining: !Int16, %minus_new_given: !Int16)
  %new_fn = prim thunk_extract_value(%o_target: !$UnsafePtr)

  ; Compute the number of oversaturated arguments
  %oversaturated = prim int16_add(%given: !Int16, %remaining: !Int16)

  %o_type = prim thunk_get_type(%new_remaining: !Int16, %new_given: !Int16)

  case %o_type: !Int int ( 0 to o_unsaturated ) otherwise o_thunk

o_unsaturated:
  %ou_result = prim thunk_alloc_copy(%new_given: !Int16, %a: !$UnsafePtr)
  %ou_written = prim thunk_write(
    %ou_result: !$UnsafePtr,
    %new_header: !Int,
    %o_target: !$UnsafePtr,
    %new_fn: !$UnsafePtr,
    %new_remaining: !Int16,
    %new_given: !Int16)
  %ou_write_result = prim thunk_write_value(%a: !$UnsafePtr, %ou_result: !$UnsafePtr)
  ; %debug3 = call @trace_thunk_done[1]: ( !$UnsafePtr -> Int ) $ (%a: !$UnsafePtr)
  return %ou_result: !$UnsafePtr

o_thunk:
  %ot_written = prim thunk_write(
    %a: !$UnsafePtr,
    %new_header: !Int,
    %o_target: !$UnsafePtr,
    %new_fn: !$UnsafePtr,
    %new_remaining: !Int16,
    %new_given: !Int16)

  %ot_value = call @eval_thunk[1]: (!$UnsafePtr -> $UnsafePtr) $ (%a: !$UnsafePtr)
  return %ot_value: !$UnsafePtr

oversaturated_target:
  ; Evaluate target first
  %target = prim thunk_extract_target(%a: !$UnsafePtr)
  %target_evaluated = call @eval_thunk[1]: (!$UnsafePtr -> $UnsafePtr) $ (%target: !$UnsafePtr)

  ; Compute new value for remaining
  %target_remaining = prim thunk_extract_remaining(%target_evaluated: !$UnsafePtr)
  %minus_given = prim int16_neg(%given: !Int16)
  %ota_new_remaining = prim int16_add(%target_remaining: !Int16, %minus_given: !Int16)

  %target_fn = prim thunk_extract_value(%target_evaluated: !$UnsafePtr)
  %ota_new_header = literal int 0

  %target_ = prim thunk_write(
    %a: !$UnsafePtr,
    %ota_new_header: !Int,
    %target_evaluated: !$UnsafePtr,
    %target_fn: !$UnsafePtr,
    %ota_new_remaining: !Int16,
    %given: !Int16)

  %ota_value = call @eval_thunk[1]: (!$UnsafePtr -> $UnsafePtr) $ (%a: !$UnsafePtr)
  return %ota_value: !$UnsafePtr
}
