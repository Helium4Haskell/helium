-- ------------------------------------------------------------------------
-- -- Declarations                                                       --
-- ------------------------------------------------------------------------

ATTR MaybeDeclarations Declaration Declarations [ | | whereDeclarationTypes USE { ++ } { [] } : { [(Name, TpScheme)] } ]
ATTR Declaration Declarations [ | patBindNr : Int | ]
ATTR MaybeDeclarations [ | | whereDeclarations : {[(Name, CoreDecl)]} ]

ATTR Declaration Declarations MaybeDeclarations [
        typeClassContext : TypeClassContext
    |
    |   functionNames USE {(++)} {[]}: {[Name]}
        declNames USE {(++)} {[]}: {[Name]}
        collectDefaults USE {(++)} {[]} : {[(Name, CoreDecl)]}
    ]

SEM Body
    | Body
        declarations.isTopLevel = True        
        declarations.typeClassContext = TCCNone

SEM Expression
    | Let
        declarations.typeClassContext = TCCNone
        loc.typeEnv = addToTypeEnv @lhs.typeEnv @declarations.whereDeclarationTypes
        expression.typeEnv = @loc.typeEnv
        declarations.typeEnv = @loc.typeEnv

SEM Qualifier
    | Let
        declarations.typeClassContext = TCCNone
        loc.env = addToTypeEnv @lhs.typeEnv @declarations.whereDeclarationTypes
        declarations.typeEnv = @loc.env
        lhs.typeEnv = @loc.env

SEM Statement
    | Let
        declarations.typeClassContext = TCCNone
        loc.env = addToTypeEnv @lhs.typeEnv @declarations.whereDeclarationTypes
        declarations.typeEnv = @loc.env
        lhs.typeEnv = @loc.env

SEM MaybeDeclarations [ | |   core : { Core.Expr -> Core.Expr } ]
    | Nothing     lhs.core = \continue -> continue
                  lhs.whereDeclarations = []
    | Just        declarations.patBindNr = 0
                  declarations.isTopLevel = False
                  declarations.moduleQual = internalError "ToCoreDecl.ag" "n/a" "toplevel MaybeDeclarations"
                  declarations.importEnv = @lhs.importEnv
                  lhs.whereDeclarations = zip @declarations.declNames @declarations.decls
                  lhs.core = \continue -> letrec_ @declarations.decls continue

SEM Declaration
    | Type
            loc.qualname = if @lhs.isTopLevel 
                             then addQualified @lhs.moduleQual @simpletype.name
                             else @simpletype.name
            lhs.decls  =
        let -- if we would have the collected type synonym information here, things could have been
            -- done much easier.
            Quantification (_, qmap, tp) = makeTpSchemeFromType (convertTypeToQualified @lhs.importEnv @type.self)
            getQuantor :: String -> Int -> ((Int, String), Int)
            getQuantor name freeIndex = case find (\(_, x) -> name == x) qmap of
              Just (idx, _) -> ((idx, name), idx)
              Nothing -> ((freeIndex, name), freeIndex)
            (qmap', quantors) = unzip $ zipWith getQuantor (map getNameName @simpletype.typevariables) [free..]
            ts = Quantification (quantors, qmap', tp)
            free = maximum (map fst qmap) + 1
        in
        [ Core.DeclTypeSynonym
            { Core.declName = idFromName @qualname
            , Core.declAccess = Core.Private
            , Core.declModule  = Nothing
            , Core.declSynonym = Core.TypeSynonymAlias
            , Core.declType = toCoreType @lhs.quantors (convertTpSchemeToQualified @lhs.importEnv ts)
            , Core.declCustoms = []
            }
        ]

    | Data    constructors.dataTypeName = @qualname
              constructors.dataTypeCoreType = @simpletype.coreType
              constructors.typevariables = @simpletype.typevariables
              loc.qualDers = map (convertClassNameToQualified @lhs.importEnv) @derivings.self
              loc.qualname = if @lhs.isTopLevel 
                               then addQualified @lhs.moduleQual @simpletype.name
                               else @simpletype.name
              lhs.decls  =
        map snd @constructors.cons
        ++
        [Core.DeclCustom
            { Core.declName    = idFromName @qualname
            , Core.declAccess  = Core.Private
            , Core.declModule  = Nothing
            , Core.declKind    = Core.DeclKindCustom (idFromString "data")
            , Core.declCustoms = [Core.CustomInt (length @simpletype.typevariables)]
            }]
        ++
        @selectorFunctions
        ++
        (if "Prelude.Show" `elem` map show @qualDers
         then [ DerivingShow.dataDictionary @lhs.importEnv @self [] @qualname ]
         else []
        )
        ++
        (if "Prelude.Eq" `elem` map show @qualDers
         then [ DerivingEq.dataDictionary @lhs.importEnv @self @qualname ]
         else []
        )

    --  range                    : Range
    --  context                  : ContextItems
    --  simpletype               : SimpleType
    --  constructors             : Constructors
    --  derivings                : Names

    | FunctionBindings
                        (loc.tpScheme, loc.declType) = declarationType @lhs.typeOutput @lhs.typeClassContext @lhs.quantors @bindings.name
                        loc.ids      = freshIds "u$" @bindings.arity
                        bindings.ids = @loc.ids
                        bindings.range = @range.self
                        lhs.declNames = [@bindings.name]
                        loc.instanceDict = [idFromString $ "$instanceDict" ++ show name | Just name <- [@lhs.instanceName]]
                        loc.dictionaries = @instanceDict ++ (map predicateToId (getPredicateForDecl @bindings.name @lhs.dictionaryEnv))
                        lhs.whereDeclarationTypes = [(@bindings.name, @loc.tpScheme)]
                        loc.qualname = if @lhs.isTopLevel
                                        then addQualified @lhs.moduleQual @bindings.name
                                        else @bindings.name
                        (bindings.quantors, loc.bindLambdas) = addLambdas @lhs.typeOutput @lhs.typeClassContext @lhs.quantors @lhs.betaDeclUnique @bindings.name (@dictionaries ++ @ids)
                        lhs.decls =
        [ Core.DeclValue
            { Core.declName    = idFromName @qualname
            , Core.declAccess  = Core.Private
            , Core.declModule  = Nothing
            , Core.declType    = @loc.declType
            , Core.valueValue  = @loc.bindLambdas @bindings.core
            , Core.declCustoms = []
            }
        ]
    --  range                    : Range
    --  bindings                 : FunctionBindings -- should all be for the same function

    | PatternBinding    lhs.patBindNr = @lhs.patBindNr + 1
                        loc.dictionaries =
                            case @pattern.self of
                                Pattern_Variable _ n ->
                                   map predicateToId
                                      (getPredicateForDecl n @lhs.dictionaryEnv)
                                _ -> []
                        lhs.whereDeclarationTypes = @pattern.vars
                        (righthandside.quantors, lhs.decls) =
        case  @pattern.self of
            Pattern_Variable _ n ->
                let (quantors, bindLambdas) = addLambdas @lhs.typeOutput @lhs.typeClassContext @lhs.quantors @lhs.betaDeclUnique n @dictionaries
                in (quantors,
                    [ Core.DeclValue
                        { Core.declName    = idFromName (if @lhs.isTopLevel then addQualified @lhs.moduleQual n else n)
                        , Core.declAccess  = Core.Private
                        , Core.declModule  = Nothing
                        , Core.declType    = snd $ declarationType @lhs.typeOutput @lhs.typeClassContext @lhs.quantors n
                        , Core.valueValue  =
                            bindLambdas
                                (\_ retType -> let_ -- because guards can fail
                                    nextClauseId retType (patternMatchFail "pattern binding" retType @range.self)
                                    @righthandside.core
                                )
                        , Core.declCustoms = []
                        }
                    ]
                )
            _ ->
              -- TODO: Add type arguments
              let patBindTp = findCoreType @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique
              in (@lhs.quantors,
                    Core.DeclValue
                        { Core.declName    = patBindId
                        , Core.declAccess  = Core.Private
                        , Core.declModule  = Nothing
                        , Core.declType    = patBindTp
                        , Core.valueValue  =
                            let_ -- because guards can fail
                                nextClauseId patBindTp (patternMatchFail "pattern binding" patBindTp @range.self)
                                @righthandside.core
                        , Core.declCustoms = [custom "type" "patternbinding"]
                        }
                    :
                    [ Core.DeclValue
                        { Core.declName    = idFromName v
                        , Core.declAccess  = Core.Private
                        , Core.declModule  = Nothing
                        , Core.declType    = tp
                        , Core.valueValue  =
                            (let_ nextClauseId tp (patternMatchFail "pattern binding" tp @range.self)
                                (patternToCore @lhs.importEnv @lhs.quantors @pattern.patternTypes (patBindId, patBindTp, @pattern.self) (Core.Var (idFromName v)))
                            )
                        , Core.declCustoms = []
                        }
                    | (v, tp) <- M.assocs @pattern.patternTypes
                    -- TODO: Check if this is necessary
                    -- | v1 <- @pattern.vars, let allv = v1 : if @lhs.isTopLevel then [addQualified @lhs.moduleQual v1] else [], v <- allv ]
                    ]
                )
                where
                    patBindId = idFromString ("patBind$" ++ show @lhs.patBindNr)
    --  range                    : Range
    --  pattern                  : Pattern
    --  righthandside            : RightHandSide

    | TypeSignature         lhs.decls    = []
                            lhs.functionNames = @names.self
    --  range                    : Range
    --  names                    : Names
    --  type                     : Type   -- may have context

    | Fixity            loc.ops      = filter (const @lhs.isTopLevel) @operators.self
                           .origin   = \n -> case Module.findInfixOrigin @lhs.extraDecls n of
                                        Nothing -> @lhs.moduleQual
                                        Just n -> getQualifiedFromString (stringFromId n)
                           .origins  = map (@origin . idFromName) @ops
                           .zipped   = zip @ops @origins
                        lhs.decls    =
        map
            ( ( \(n, orig) ->
                Core.DeclCustom
                    { Core.declName    = idFromName $ addQualified orig n
                    , Core.declAccess  = Core.Private
                    , Core.declModule  = Nothing
                    , Core.declKind    = (Core.DeclKindCustom . idFromString) "infix"
                    , Core.declCustoms =
                        [ Core.CustomInt
                             ( case @priority.self of
                                  MaybeInt_Just i  -> i
                                  MaybeInt_Nothing -> 9 )
                        , (Core.CustomBytes . bytesFromString)
                              ( case @fixity.self of
                                   Fixity_Infixr _ -> "right"
                                   Fixity_Infixl _ -> "left"
                                   Fixity_Infix  _ -> "none"
                            --       _               -> internalError
                            --                            "ToCoreDecl.ag"
                            --                            "SEM Declaration.Fixity"
                            --                            "unknown fixity"
                              )
                        ]
                    }
              )
            )
            $ @zipped 
            -- concatMap (\n -> [n] ++ if @lhs.isTopLevel then [addQualified @lhs.moduleQual n] else []) @operators.self
    --  range                    : Range
    --  fixity                   : Fixity
    --  priority                 : MaybeInt
    --  operators                : Names
    | Class             loc . superClasses = getSuperClasses @contextQual
                            . contextQual  = map (convertContextItemToQualified @lhs.importEnv) @context.self
                            . qualName     = convertClassNameToQualified @lhs.importEnv @simpletype.name
                        lhs.decls    = let
                                            isInfix (Module.DeclCustom{
                                                Core.declKind = (Core.DeclKindCustom n)
                                            }) = stringFromId n `isSuffixOf` " infix"
                                            isInfix _ = False
                                        in (classFunctions @lhs.moduleQual @lhs.typeOutput (getNameName @qualName) (getNameName $ head @simpletype.typevariables) $ constructFunctionMap @lhs.importEnv (length @superClasses) @qualName) ++
                                        [
                                            Core.DeclCustom
                                                {
                                                    --declName :: Id, declAccess :: !Access, declArity :: !Arity, declCustoms :: ![Custom]
                                                    Core.declName = idFromName @qualName,
                                                    Core.declAccess = Core.Private,
                                                    Core.declModule = Nothing,
                                                    Core.declKind = Core.DeclKindCustom $ idFromString "ClassDefinition",
                                                    Core.declCustoms =
                                                        constructClassMemberCustomDecl @lhs.importEnv @qualName (M.lookup @qualName $ classMemberEnvironment @lhs.importEnv) []
                                                }
                                        ] ++ convertDictionaries @lhs.typeOutput @qualName @where.functionNames @where.whereDeclarations
                                         ++ (filter isInfix @where.decls)
                        where . instanceName = Just @qualName
                        where . typeClassContext = TCCClass
                        where . dictionaryEnv = setCurrentClassNames (zip @where.functionNames (repeat ("$instanceDict" ++ show @qualName))) @lhs.dictionaryEnv
    | Instance          lhs .   decls    =  [ constructDictionary
                                                @lhs.typeOutput
                                                (getSuperClasses @contextQual)
                                                (constructFunctionMap @lhs.importEnv (length @superClasses) @qualName)
                                                @where.whereDeclarations 
                                                @qualName 
                                                @loc.typeName (map (\(n, TVar i) -> (n, i)) @instanceBetas)
                                                (typeToCoreType @quantors @tp)
                                                []
                                            ]
                        loc .   quantors    = quantorsFromList $ map (\(_, TVar i) -> i) @instanceBetas
                        where . quantors    = @quantors
                        loc .   qualName    = convertClassNameToQualified @lhs.importEnv @name.self
                        loc .   contextQual = map (convertContextItemToQualified @lhs.importEnv) @context.self
                        loc .   tp = convertTpToQualified @lhs.importEnv $ makeTpFromType @instanceBetas @type
                        loc .   typeName = showInstanceType @tp
                        loc .   err = error $ "Invalid class name " ++ getNameName @qualName
                        -- loc .   superClasses = fst (fromMaybe @err (M.lookup (getNameName @qualName) (classEnvironment @lhs.importEnv)))
                        -- loc .   typevariables = zip (namesInType @loc.type) [TVar n | n <- [0..]]
                        loc .   type = head @types.self
                        where . instanceName = Just @qualName
                        where . typeClassContext = TCCInstance (idFromName @name.self) (toCoreTypeNotQuantified $ makeTpSchemeFromType @loc.type)

    | Newtype           constructor.isNewtype = True
                        constructor.dataTypeName = @qualname
                        constructor.dataTypeCoreType = @simpletype.coreType
                        constructor.typevariables = @simpletype.typevariables
                        loc.qualname = addQualified @lhs.moduleQual @simpletype.name
                        loc.constructorDecl = snd $ head @constructor.cons
                        loc.transparent = case M.lookup (nameFromId $ Core.declName @constructorDecl) $ valueConstructors @lhs.importEnv of
                                            Just (_, _, True) -> True
                                            _ -> False
                        lhs.decls    =
        if @transparent then
          [ @constructorDecl
          , Core.DeclTypeSynonym
            { Core.declName    = idFromName @qualname
            , Core.declAccess  = Core.Private
            , Core.declModule  = Nothing
            , Core.declSynonym = Core.TypeSynonymNewtype
            , Core.declType    = Core.typeSynonymTypeFromConstructorType $ Core.declType @constructorDecl
            , Core.declCustoms = [Core.CustomInt (length @simpletype.typevariables)]
            }
          ]
        else
          [ @constructorDecl
          , Core.DeclCustom
            { Core.declName    = idFromName @qualname
            , Core.declAccess  = Core.Private
            , Core.declModule  = Nothing
            , Core.declKind    = Core.DeclKindCustom (idFromString "data")
            , Core.declCustoms = [Core.CustomInt (length @simpletype.typevariables)]
            }
          ]

    | Foreign   (loc.tpScheme, loc.tp) = declarationType @lhs.typeOutput @lhs.typeClassContext @lhs.quantors @fdecl.name
                (loc.qualname, _, _)
                    = if @lhs.isTopLevel 
                        then ( addQualified @lhs.moduleQual @fdecl.name
                             , Core.Export (idFromName @fdecl.name)
                             , Just (idFromString @lhs.modulename))
                        else (@fdecl.name, Core.Private, Nothing)
                lhs.whereDeclarationTypes = [(@fdecl.name, @tpScheme)]
                lhs.decls = 
                    [ Core.DeclAbstract 
                        { Core.declName        = idFromName @qualname 
                        , Core.declAccess      = Core.Private
                        , Core.declModule      = Nothing
                        , Core.declArity       = getArity @loc.tp
                        , Core.declType        = setAllStrict @loc.tp
                        , Core.declForeignName = Just @fdecl.fname
                        , Core.declCustoms     = []
                        }
                    ]

    --  range                    : Range
    --  context                  : ContextItems
    --  simpletype               : SimpleType
    --  constructor              : Constructor  -- has only one field, no strictness
    --  derivings                : Names

    -- Not supported

    | Default           lhs.decls    = internalError "ToCoreDecl" "Declaration" "'default' not supported"
    --  range                    : Range
    --  types                    : Types        -- should be instances of Num

    | Empty             lhs.decls    = internalError "ToCoreDecl" "Declaration" "empty declarations not supported"
    --  range                    : Range

--- Compute arity based on the type information
--- only used for FFI
--- FIXME: Currently not used
ATTR Name Type Types FDecl [ | | arity : Int ]
ATTR Name Type [ | isFunc : Bool | ]

SEM Name
    | Identifier lhs . arity  = 1
                 lhs . isFunc = False
    | Special    lhs . arity  = 0
                 lhs . isFunc = @name == "->"

SEM Type
    | Application lhs . arity  = if @fun then @arguments.arity else 1
                  loc . fun = @function.isFunc
    | Constructor lhs . arity  = @name.arity
                  lhs . isFunc = @name.isFunc

SEM Types
    | Cons lhs.arity = @hd.arity + @tl.arity
    | Nil  lhs.arity = -1

SEM FDecl 
    | Import lhs.arity = @type.arity
    | Export lhs.arity = @type.arity
---

--- Record the foreign function name for FFI functions
ATTR FDecl [ | | fname : String]

SEM FDecl
    | Import lhs.fname = @impend
    | Export lhs.fname = @expend

---

ATTR FunctionBinding FunctionBindings
    [   ids : { [Id] }
    |
    |   arity : Int
    ]

SEM FunctionBindings [ range : Range | | core : {[Core.Type] -> Core.Type -> Core.Expr}  ]
    | Cons             lhs.core  = \args retType -> @hd.core args retType $ @tl.core args retType
                          .arity = @hd.arity
    | Nil              lhs.core  = \_ retType -> patternMatchFail "function bindings" retType @lhs.range
                          .arity = internalError "ToCoreDecl" "FunctionBindings" "arity: empty list of function bindings"

SEM FunctionBinding [ | | core : { [Core.Type] -> Core.Type -> Core.Expr -> Core.Expr} ]
    | Hole             lhs.arity = 0
                          . core = internalError "ToCoreDecl" "FunctionBinding" "holes not supported"
    | FunctionBinding  lhs.arity = @lefthandside.arity
                       lhs.core =
        \args retType nextClause ->
            let thisClause =
                    patternsToCore
                        @lhs.importEnv
                        @lhs.quantors
                        @lefthandside.patternTypes
                        (zip3 @lhs.ids args @lefthandside.patterns)
                        @righthandside.core in
            if all patternAlwaysSucceeds @lefthandside.patterns
               &&
               not @righthandside.isGuarded
            then
                thisClause
            else
                let_ nextClauseId retType nextClause thisClause

    --  range                    : Range
    --  lefthandside             : LeftHandSide
    --  righthandside            : RightHandSide
{
predicateToId :: Predicate -> Id
predicateToId (Predicate class_ tp) =
    idFromString $ "$dict" ++ class_ ++ "$" ++ show tp

dictionaryTreeToCore :: Quantors -> DictionaryTree -> Core.Expr
dictionaryTreeToCore quantors theTree =
   case theTree of
        ByPredicate predicate ->
            Core.Var (predicateToId predicate)
        ByInstance className instanceName typeArgs trees ->
            foldl Core.Ap
                (foldl Core.ApType
                    (Core.Var (idFromString ("$dict"++className++ "$" ++ instanceName)))
                    $ map (typeToCoreType quantors) typeArgs
                )
                (map (dictionaryTreeToCore quantors) trees)
        BySuperClass subClass superClass tp tree ->
            Core.Ap (Core.ApType (Core.Var (idFromString ("$get" ++ superClass ++ "$" ++ subClass))) $ typeToCoreType quantors tp)
                (dictionaryTreeToCore quantors tree)
        ByCurrentClass className ->
            Core.Var (idFromString $ "$instanceDict" ++ className)
        BySuperInstance p className typeVariables ->
            Core.Var (idFromString $ "$instanceDict" ++ className ++ "$" ++ typeVariables )


insertDictionaries :: Quantors -> Name -> DictionaryEnvironment -> Core.Expr -> Core.Expr
insertDictionaries quantors name dictionaryEnv expr =
   foldl Core.Ap
         expr
         ((map (dictionaryTreeToCore quantors) (getDictionaryTrees name dictionaryEnv)))
}
ATTR LeftHandSide
    [
    |
    |   arity : Int
        patterns : Patterns
    ]

SEM LeftHandSide
    | Function         lhs.arity = @patterns.length
                          .patterns = @patterns.self
    --  range                    : Range
    --  name                     : Name
    --  patterns                 : Patterns

    | Infix            lhs.arity = 2
                          .patterns = [@leftPattern.self, @rightPattern.self ]
    --  range                    : Range
    --  leftPattern              : Pattern
    --  operator                 : Name
    --  rightPattern             : Pattern

    | Parenthesized    lhs.arity = @lefthandside.arity + @patterns.length
                          .patterns = @lefthandside.patterns ++ @patterns.self
    --  range                    : Range
    --  lefthandside             : LeftHandSide
    --  patterns                 : Patterns

SEM RightHandSide
    [
    |
    |   core : { Core.Expr }
        isGuarded : Bool
    ]

    | Expression        lhs . core = @where.core @expression.core
                        loc . typeEnv = addToTypeEnv @lhs.typeEnv @where.whereDeclarationTypes
                            . isGuarded = False
                        where.instanceName = Nothing
                             .typeClassContext = TCCNone
                             .typeEnv = @typeEnv
                             .modulename = internalError "ToCoreDecl.ag" "RightHandSide.Expression - modulename" ""
                        expression.typeEnv = @typeEnv
    --  range                    : Range
    --  expression               : Expression
    --  where                    : MaybeDeclarations

    | Guarded         lhs.isGuarded = True
                         .core = @where.core (foldr ($) (Core.Var nextClauseId) @guardedexpressions.core)
                      where.instanceName = Nothing
                      where.typeClassContext = TCCNone
                      loc.typeEnv = addToTypeEnv @lhs.typeEnv @where.whereDeclarationTypes
                      guardedexpressions.typeEnv = @typeEnv
                      where.typeEnv = @typeEnv

    --  range                    : Range
    --  guardedexpressions       : GuardedExpressions
    --  where                    : MaybeDeclarations

-- ------------------------------------------------------------------------
-- -- Record Field                                                       --
-- ------------------------------------------------------------------------
{-
Each field will correspond to a single top-level function where the constructors
where it is present will all appear in the pattern of the function
-}

ATTR Constructor Constructors
    [ isNewtype : Bool | | names USE { ++ } { [] } : Names ]

ATTR FieldDeclaration FieldDeclarations
    [ fieldMap : { M.Map Name (Int, Bool, Tp, TpScheme) } | | ]

SEM Declaration
    | Data 
            constructors.isNewtype = False
            loc.selectorFunctions = map @toDecl @fieldTypes
              .toDecl = \(n, t, ts) -> Core.DeclValue
                                    { Core.declName    = idFromName (addQualified @lhs.moduleQual n)
                                    , Core.declAccess  = Core.Private
                                    , Core.declModule  = Nothing
                                    , Core.declType    = toCoreType @lhs.quantors (convertTpSchemeToQualified @lhs.importEnv ts)
                                    , Core.valueValue  = createRecordSelector @lhs.importEnv @lhs.quantors @range.self n t
                                    , Core.declCustoms = []
                                    }
              .recordEnv = recordEnvironment @lhs.importEnv
              .fieldTypes = map (\(n, (i, s, t, ts)) -> (n, t, ts)) (M.assocs @fieldMap)
              .fieldMap = fromMaybe (internalError "ToCoreDecl" "Declaration.Data" "selectorFunctions")
                            $ M.unions <$> sequence (map (`M.lookup` @recordEnv) @constructors.names)

SEM Constructor [ | | ]
    | Constructor       lhs . names = [ @constructor.self ]
    | Record            lhs . names = [ @constructor.self ]
                  loc . fields  = map (\(n, (i, s, t, ts)) -> Module.Field (idFromName n)) @sortedFields
                      . sortedFields = sortOn (fst4 . snd) (M.assocs @fieldMap)
                      . fieldMap
                            = fromMaybe (internalError "ToCoreDecl" "Constructor.Record" "constructor not found")
                                $ M.lookup @constructor.self (recordEnvironment @lhs.importEnv)

-- ------------------------------------------------------------------------
-- -- Types                                                              --
-- ------------------------------------------------------------------------

ATTR Constructors Constructor
    [
    |
    |   cons USE { ++ } { [] } : { [(Id, CoreDecl)] }
    ]

SEM Constructors [ dataTypeName : Name typevariables : Names dataTypeCoreType : { Core.Type } | | ]

SEM Constructor [ dataTypeName : Name typevariables : Names dataTypeCoreType : { Core.Type } | | ]
    | Constructor       lhs.cons =
        map (\n ->
            (idFromName @constructor.self, Core.DeclCon
                { Core.declName    = idFromName @constructor.self
                , Core.declAccess  = Core.Private
                , Core.declModule  = Nothing
                , Core.declType    = declarationConstructorType @lhs.importEnv @constructor.self (if @lhs.isNewtype then [True] else @types.strictness)
                , Core.declCustoms = constructorCustoms
                                        @lhs.dataTypeName
                                        @constructor.self
                                        (valueConstructors @lhs.importEnv)
                , Core.declFields  = []
                }
            )) [addQualified @lhs.moduleQual @constructor.self]
    --  range                    : Range
    --  constructor              : Name
    --  types                    : AnnotatedTypes

    | Infix
        lhs.cons = 
            map (\n ->
                (idFromName n, Core.DeclCon
                    { Core.declName    = idFromName n
                    , Core.declAccess  = Core.Private
                    , Core.declModule  = Nothing
                    , Core.declType    = declarationConstructorType @lhs.importEnv @constructorOperator.self [@leftType.strictness, @rightType.strictness]
                    , Core.declCustoms = constructorCustoms
                                            @lhs.dataTypeName
                                            @constructorOperator.self
                                            (valueConstructors @lhs.importEnv)
                    , Core.declFields  = []
                    }
                )) [@constructorOperator.self, addQualified @lhs.moduleQual @constructorOperator.self]
    --  range                    : Range
    --  leftType                 : AnnotatedType
    --  constructorOperator      : Name
    --  rightType                : AnnotatedType

    | Record            lhs.cons =
        [ (idFromName @constructor.self, Core.DeclCon
            { Core.declName    = idFromName @constructor.self
            , Core.declAccess  = Core.Private
            , Core.declModule  = Nothing
            , Core.declType    = declarationConstructorType @lhs.importEnv @constructor.self @fieldDeclarations.strictness
            , Core.declCustoms = constructorCustoms
                                    @lhs.dataTypeName
                                    @constructor.self
                                    (valueConstructors @lhs.importEnv)
            , Core.declFields = @fields
            }
          )
        ]

    --  range                    : Range
    --  constructor              : Name
    --  fieldDeclarations        : FieldDeclarations

SEM FieldDeclarations [ | | strictness : { [Bool] } ]
    | Cons lhs.strictness = @hd.strictness : @tl.strictness
    | Nil  lhs.strictness = []

SEM FieldDeclaration [ | | strictness : { Bool } ]
    | FieldDeclaration lhs.strictness = @type.strictness
    --  range                    : Range
    --  names                    : Names
    --  type                     : AnnotatedType

SEM AnnotatedTypes [ | | strictness : { [Bool] } ]
    | Cons lhs.strictness = @hd.strictness : @tl.strictness
    | Nil  lhs.strictness = []

SEM AnnotatedType [ | | strictness : { Bool } ]
    | AnnotatedType lhs.strictness = @strict
{
constructorCustoms :: Name -> Name -> ValueConstructorEnvironment -> [Core.Custom]
constructorCustoms dataTypeName name envWithParent =
    maybe
        (internalError "ToCoreDecl" "Constructor" ("no type found for " ++ show name))
        (\tpScheme ->
            [ custom "type" (show tpScheme)
            , Core.CustomLink
                    (idFromName dataTypeName)
                    (Core.DeclKindCustom (idFromString "data"))
            ]
        )
        (M.lookup name env)
    where
        env = M.map (\(_, scheme, _) -> scheme) envWithParent
}
