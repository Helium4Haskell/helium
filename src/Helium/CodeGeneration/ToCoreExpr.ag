-- ------------------------------------------------------------------------
-- -- Expressions                                                        --
-- ------------------------------------------------------------------------

SEM MaybeExpression [ | | core : { Maybe Core.Expr } ]
    | Nothing       lhs.core = Nothing
    | Just          lhs.core = Just @expression.core
    --  expression               : Expression


ATTR Expressions [ | | core USE { : } { [] } : { [Core.Expr] } ]

SEM Expression [ | | core : { Core.Expr } ]
    | Literal            lhs.core = @literal.core      
    --  range                    : Range
    --  literal                  : Literal

    | Variable           lhs.core = insertDictionaries @lhs.quantors @name.self @lhs.dictionaryEnv $ 
                                        createInstantiation @lhs.typeOutput @lhs.typeEnv @lhs.quantors @name.self False @lhs.betaDeclUnique
    --  range                    : Range
    --  name                     : Name

    | Hole               lhs.core = Core.Var (idFromString "undefined")
    --  range                    : Range
    --  id                       : Integer

    | Constructor        lhs.core = createInstantiation @lhs.typeOutput @lhs.typeEnv @lhs.quantors @name.self True @lhs.betaDeclUnique
    --  range                    : Range
    --  name                     : Name

    | Parenthesized      lhs.core = @expression.core
    --  range                    : Range
    --  expression               : Expression

    | NormalApplication  lhs.core = foldl Core.Ap @function.core @arguments.core  
    --  range                    : Range
    --  function                 : Expression
    --  arguments                : Expressions

    | InfixApplication   lhs.core =
        case (@leftExpression.core, @rightExpression.core) of
            (Nothing, Nothing) -> @operator.core
            (Just l , Nothing) -> Core.Ap @operator.core l
            (Nothing, Just r ) ->
                addLambdasForLambdaExpression @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique [parameterId]
                    (\_ _ -> Core.Ap (Core.Ap @operator.core $ Core.Var parameterId) r)
            {-
                -- At most one new variable is needed. Consider
                --  (. (+ 3))  ==  \x -> (.) x (\x -> (+) x 3)
            -}
            (Just l , Just r ) -> foldl Core.Ap @operator.core [l,r]
    --  range                    : Range
    --  leftExpression           : MaybeExpression
    --  operator                 : Expression
    --  rightExpression          : MaybeExpression

    | If                 lhs.core = 
        if_ @guardExpression.core @thenExpression.core @elseExpression.core
    --  range                    : Range
    --  guardExpression          : Expression
    --  thenExpression           : Expression
    --  elseExpression           : Expression

    | Lambda             lhs.core = 
        let ids = freshIds "u$" @patterns.length
        in addLambdasForLambdaExpression @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique ids
            (\tps retType -> 
                let_ nextClauseId retType (patternMatchFail "lambda expression" retType @range.self)
                  $ patternsToCore
                    @lhs.importEnv
                    @lhs.quantors
                    @patterns.patternTypes
                    (zip3 ids tps @patterns.self) 
                    @expression.core)

    --  range                    : Range
    --  patterns                 : Patterns
    --  expression               : Expression

    | Case               loc.scrutineeType = findCoreType @lhs.typeOutput @lhs.quantors $ @lhs.betaDeclUnique + 1
                         lhs.core = let_ caseExprId @loc.scrutineeType @expression.core @alternatives.core
                         alternatives.caseRange = @range.self
                         alternatives.scrutineeType = @loc.scrutineeType
                         alternatives.rhsType = findCoreType @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique
    --  range                    : Range
    --  expression               : Expression
    --  alternatives             : Alternatives

    | Let                declarations.patBindNr = 0
                         declarations.isTopLevel = False
                         declarations.moduleQual = internalError "ToCoreExpr.ag" "n/a" "toplevel Expression"
                         lhs.core =
        letrec_ @declarations.decls @expression.core
    --  range                    : Range
    --  declarations             : Declarations
    --  expression               : Expression

    | Do                 loc.monadType = findCoreType @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique
                         statements.monadType = @loc.monadType
                         statements.returnType = findCoreType @lhs.typeOutput @lhs.quantors (@lhs.betaDeclUnique + 1)
                         lhs.core = let_ (idFromString "$monadDict") 
                                        (Core.TAp (Core.TCon $ Core.TConTypeClassDictionary $ idFromString "Prelude.Monad") @loc.monadType) 
                                        (dictionaryTreeToCore @lhs.quantors $ head $ getDictionaryTrees @loc.name @lhs.dictionaryEnv) $ 
                                        chainCode @statements.core
                         loc.name = setNameRange (nameFromString $ "do-" ++ show @range.self) @range.self
    --  range                    : Range
    --  statements               : Statements

    | List               lhs.core = coreList (findCoreType @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique) @expressions.core
    --  range                    : Range
    --  expressions              : Expressions

    | Tuple              lhs.core = 
        let
            tp = findCoreType @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique
            tps = Core.typeTupleElements tp
            constructor =
                foldl Core.ApType (Core.Con $ Core.ConTuple $ length @expressions.core) tps  
        in foldl 
            Core.Ap 
            constructor
            @expressions.core
    --  range                    : Range
    --  expressions              : Expressions

    | Comprehension      loc.tp = findCoreType @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique
                         qualifiers.coreType = @loc.tp
                         lhs.core = 
        let singleton x = cons @loc.tp x $ nil @loc.tp
        in foldr ($) (singleton @expression.core) @qualifiers.core
    --  range                    : Range
    --  expression               : Expression
    --  qualifiers               : Qualifiers

    | Typed              lhs.core = @expression.core
    --  range                    : Range
    --  expression               : Expression
    --  type                     : Type

    -- negate is overloaded and we need to insert a dictionary argument
    | Negate             loc.tp   = findCoreType @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique
                         lhs.core =
            insertDictionaries @lhs.quantors (setNameRange intUnaryMinusName @range.self) @lhs.dictionaryEnv 
                (Core.Var (idFromName intUnaryMinusName) `Core.ApType` @loc.tp)
                `app_` @expression.core 
    --  range                    : Range
    --  expression               : Expression

    | NegateFloat        lhs.core = 
            var "$primNegFloat" `app_` @expression.core 
    --  range                    : Range
    --  expression               : Expression

    -- enumerations are overloaded and we need to insert a dictionary argument
    | Enum               loc.tp = findCoreType @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique
                         lhs.core = 
            case (@then.core, @to.core) of
                -- TODO: `enumFromName` and friends are now qualified. However, we cannot pass a qualified name to insertDictionaries.
                -- As a workaround we construct non-qualified names here. They might not be in scope everywhere, so this may fail.
                -- We should fix this, by inserting the Enum dictionary manually                    
                (Just then_, Just to) -> 
                    insertDictionaries @lhs.quantors (setNameRange (nameFromString "enumFromThenTo") @range.self) @lhs.dictionaryEnv
                       (Core.Var (idFromName enumFromThenToName) `Core.ApType` @loc.tp)
                       `app_` @from.core `app_` then_ `app_` to
                (Just then_, Nothing) -> 
                    insertDictionaries @lhs.quantors (setNameRange (nameFromString "enumFromThen") @range.self) @lhs.dictionaryEnv
                        (Core.Var (idFromName enumFromThenName) `Core.ApType` @loc.tp)
                       `app_` @from.core `app_` then_
                (Nothing, Just to) ->
                    insertDictionaries @lhs.quantors (setNameRange (nameFromString "enumFromTo") @range.self) @lhs.dictionaryEnv
                        (Core.Var (idFromName enumFromToName) `Core.ApType` @loc.tp)
                       `app_` @from.core `app_` to
                (Nothing, Nothing) ->
                    insertDictionaries @lhs.quantors (setNameRange (nameFromString "enumFrom") @range.self) @lhs.dictionaryEnv
                        (Core.Var (idFromName enumFromName) `Core.ApType` @loc.tp)
                       `app_` @from.core
                    
    --  range                    : Range
    --  from                     : Expression
    --  then                     : MaybeExpression
    --  to                       : MaybeExpression

    | RecordConstruction lhs.core = createRecordInstantiation
                                        @lhs.typeOutput 
                                        @lhs.quantors
                                        @name.self 
                                        (map (\(n, e, _) -> (n, e)) @recordExpressionBindings.bindings)
                                        (declarationConstructorTypeScheme (importEnv @lhs.typeOutput) @name.self)
                                        ((\b -> lookupBeta b @lhs.typeOutput) $ fromMaybe 
                                            (internalError "ToCoreExpr" "RecordConstruction" "(n/a)") 
                                            (getTVar @betaFunc))
    --  range                    : Range
    --  name                     : Name
    --  recordExpressionBindings : RecordExpressionBindings

    | RecordUpdate       lhs.core = createRecordUpdate
                                        @lhs.typeOutput
                                        @lhs.quantors
                                        @expression.core
                                        (fromMaybe 
                                            (internalError "ToCoreExpr" "RecordUpdate" "(n/a)") 
                                            (getTVar @oldBeta))
                                        (fromMaybe 
                                            (internalError "ToCoreExpr" "RecordUpdate" "(n/a)") 
                                            (getTVar @beta))
                                        @recordExpressionBindings.bindings
                                        @range.self
    --  range                    : Range
    --  expression               : Expression
    --  recordExpressionBindings : RecordExpressionBindings

ATTR Statements Statement [ monadType : { Core.Type } returnType : { Core.Type } | | ]
ATTR Statements [  | | core USE { : } { [] } : { [Maybe Core.Expr -> Core.Expr] } ]

SEM Statement [ | | core : { Maybe Core.Expr -> Core.Expr } ]
    | Expression          loc.argType = findCoreType @lhs.typeOutput @lhs.quantors @lhs.betaDeclUnique
                          lhs.core =
            \theRest -> 
                case theRest of
                    Nothing   -> @expression.core
                    Just rest -> bind @lhs.monadType @argType @lhs.returnType (Core.Var $ idFromString "$monadDict") @expression.core (Core.Lam False (Core.Variable dummyId @loc.argType) rest)
    --  range                    : Range
    --  expression               : Expression

    | Let                 declarations.patBindNr = 0
                          declarations.isTopLevel = False
                          declarations.moduleQual = internalError "ToCoreExpr.ag" "n/a" "toplevel Statement"
                          lhs.core =
            \theRest ->
                case theRest of
                    Nothing   -> internalError "ToCoreExpr" "Statement" "'let' can't be last in 'do'"
                    Just rest -> letrec_ @declarations.decls rest 
    --  range                    : Range
    --  declarations             : Declarations

    -- let _nextClause = <throw exception> in
    -- let _ok = \_misc -> case _misc of { pattern -> ...; _ -> _nextClause }
    -- in expression >>= ok
    | Generator           loc.argType = let (TVar beta) = @pattern.beta in findCoreType @lhs.typeOutput @lhs.quantors beta
                          lhs.core =
        \theRest -> case theRest of
            Nothing   -> internalError "ToCoreExpr" "Statement" "generator can't be last in 'do'"
            Just rest ->
                bind @lhs.monadType @argType @lhs.returnType (Core.Var $ idFromString "$monadDict") @expression.core (Core.Lam False (Core.Variable parameterId @loc.argType) (patternToCore @lhs.importEnv @lhs.quantors @pattern.patternTypes (parameterId, @loc.argType, @pattern.self) rest))

    --  range                    : Range
    --  pattern                  : Pattern
    --  expression               : Expression

-- Not supported

    | Empty               lhs.core =
            \theRest ->
                case theRest of 
                    Nothing   -> internalError "ToCoreExpr" "Statement" "empty statements not supported"
                    Just rest -> rest
    --  range                    : Range

ATTR Qualifiers Qualifier [ coreType : { Core.Type } | | ]

ATTR Qualifiers [ | | core USE { : } { [] } : { [Core.Expr -> Core.Expr] } ]

SEM Qualifier [ | | core : { Core.Expr -> Core.Expr } ]
    | Guard               lhs.core = \continue -> if_ @guard.core continue (nil @lhs.coreType)
    --  range                    : Range
    --  guard                    : Expression -- type: Boolean

    | Let                 declarations.patBindNr = 0
                          declarations.isTopLevel = False
                          declarations.moduleQual = internalError "ToCoreExpr.ag" "n/a" "toplevel Qualifier"
                          lhs.core = \continue -> letrec_ @declarations.decls continue
    --  range                    : Range
    --  declarations             : Declarations
   
    -- See Haskell report 3.11
    -- let _nextClause = [] in
    -- let _ok = \_misc -> case _misc of { pattern -> ...; _ -> _nextClause }
    -- in concatMap _ok expression

    | Generator           loc.argType = let (TVar beta) = @pattern.beta in findCoreType @lhs.typeOutput @lhs.quantors beta
                          loc.retType = (Core.TCon (Core.TConDataType $ idFromString "[]") `Core.TAp` @lhs.coreType)
                          lhs.core = 
        \continue ->  
            let_ nextClauseId @loc.retType (nil @lhs.coreType)
                (let_ 
                    okId (Core.typeFunction [@loc.argType] @loc.retType)
                    (Core.Lam False (Core.Variable parameterId @loc.argType)
                        (patternToCore @lhs.importEnv @lhs.quantors @pattern.patternTypes (parameterId, @loc.argType, @pattern.self) continue)
                    )
                    (var "$primConcatMap" `Core.ApType` @loc.argType `Core.ApType` @lhs.coreType
                        `app_` Core.Var okId 
                        `app_` @expression.core
                    )
                )
                
    --  range                    : Range
    --  pattern                  : Pattern
    --  expression               : Expression
    
-- Not supported

    | Empty               lhs.core = internalError "ToCoreExpr" "Qualifier" "empty qualifiers not supported"
    --  range                    : Range
                  
ATTR Alternatives Alternative [ scrutineeType : { Core.Type } rhsType : { Core.Type } | | ]
SEM Alternatives [ caseRange : Range | | core : { Core.Expr } ]
    | Cons              lhs.core     = @hd.core @tl.core
    | Nil               lhs.core     = patternMatchFail "case expression" @lhs.rhsType @lhs.caseRange

SEM Alternative [ | | core : { Core.Expr -> Core.Expr } ]
    | Hole              lhs.core   = id
    | Alternative       lhs.core   = \nextCase  ->
                                        let thisCase =
                                                patternToCore
                                                    @lhs.importEnv
                                                    @lhs.quantors
                                                    @pattern.patternTypes
                                                    (caseExprId, @lhs.scrutineeType, @pattern.self) 
                                                    @righthandside.core
                                        in
                                            let_ nextClauseId @lhs.rhsType nextCase thisCase
    --  range                    : Range
    --  pattern                  : Pattern
    --  righthandside            : RightHandSide

    | Empty             lhs.core   = id
    --  range                    : Range

ATTR GuardedExpressions [ | | core USE { : } { [] } : { [Core.Expr -> Core.Expr] } ]

SEM GuardedExpression [ | | core : { Core.Expr -> Core.Expr } ]
    | GuardedExpression lhs.core = 
        \fail' -> if_ @guard.core @expression.core fail'
    --  range                    : Range
    --  guard                    : Expression -- type: Boolean
    --  expression               : Expression

---------------------------------
-- Collect record construction information
-- Will be used to put the arguments in the right order

SEM RecordExpressionBindings [ | | bindings USE { : } { [] } : { [(Name, Core.Expr, Int)] } ]
    | Cons                  lhs.bindings = @hd.bind : @tl.bindings

SEM RecordExpressionBinding [ | | bind : {(Name, Core.Expr, Int)} ]
    | RecordExpressionBinding 
        lhs.bind = (@name.self, @expression.core, @lhs.betaDeclUnique)

SEM Literal [ | | core : { Core.Expr } ]
    | Int                   lhs.core = Core.Lit (Core.LitInt (read @value) Core.IntTypeInt)
    --  range                    : Range
    --  value                    : String

    | Char                  lhs.core = 
            Core.Lit (Core.LitInt (ord 
                (read ("'" ++ @value ++ "'"))) Core.IntTypeChar)
    --  range                    : Range
    --  value                    : String -- without the quotes

    | Float                 lhs.core = float @value
    --  range                    : Range
    --  value                    : String

    | String                lhs.core = stringToCore (read ("\"" ++ @value ++ "\""))
    --  range                    : Range
    --  value                    : String -- without the quotes

{

-- Function "bind" is used in the translation of do-expressions
bind :: Core.Type -> Core.Type -> Core.Type -> Core.Expr -> Core.Expr -> Core.Expr -> Core.Expr
bind tMonad tArg tReturn dict ma f = (Core.Ap instantiated dict) `app_` ma `app_` f
  where
    instantiated = (Core.Var (idFromString "Prelude.>>=")) `Core.ApType` tMonad `Core.ApType` tArg `Core.ApType` tReturn

caseExprId, okId, parameterId :: Id
(  caseExprId :  okId :  parameterId : []) = map idFromString $
  "caseExpr$" : "ok$" : "parameter$" : []

-- Function "chainCode" is used in the translation of do-expressions
chainCode :: [Maybe Core.Expr -> Core.Expr] -> Core.Expr
chainCode theCores =
    case theCores of
        [core] -> core Nothing
        (core:cores) -> core (Just (chainCode cores))
        [] -> error "pattern match failure in CodeGeneration.ToCoreExpr.chainCode"
}
