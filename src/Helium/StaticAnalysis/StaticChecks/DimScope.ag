-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
-- 
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Static check for dimensions :
-- - Undefined units
-- - Duplicated dimensions and units
-- - Recursive unit definition
--
-----------------------------------------------------------------------------

INCLUDE "UHA_Syntax.ag"

imports{
import qualified Data.Map as M
import qualified Data.List as L
}

-- 1) Add units and dims to the scope

ATTR Module Body Declarations Declaration Unit
    [ | | dimscope, unitscope USE { ++ } { [] } : { Names }
          unitdef             USE { ++ } { [] } : {[(Name, Maybe Unit)]} ]


ATTR SimpleUnit SimpleDimension   
    [ | | name : Name ]

SEM Module
    | Module                    lhs . unitscope = @body.unitscope
                                    . dimscope  = @body.dimscope
                                   --  . unitdef   = @body.unitdef

SEM Body
    | Body                      lhs . unitscope = @declarations.unitscope
                                    . dimscope  = @declarations.dimscope
                                    -- . unitdef   = @declarations.unitdef

SEM Declaration
    | Dimension                 lhs . unitscope = [@simpleunit.name]
                                    . dimscope  = [@simpledimension.name]
                                    . unitdef   = [(@simpleunit.name,Nothing)]
    | UnitFromUnit              lhs . unitscope = [@simpleunit.name]
                                    . unitdef   = [(@simpleunit.name,Just @associatedunit.self)]
    | AliasUnit                 lhs . unitscope = [@alias.name]
                                    . unitdef   = [(@alias.name,Just @aliased.self)]

SEM Unit
    | Base Variable            lhs . unitscope = []
    | Times Div Power NegPower Parenthesized One  lhs . unitscope = []

SEM SimpleUnit
    | SimpleUnit                lhs . name = @name.self

SEM SimpleDimension
    | SimpleDimension           lhs . name = @name.self


-----------------------------------------------------------------------------

--2) Distributing Units and Dimensions

SEM Module
    | Module                    loc . dscope = @body.dimscope
                                loc . uscope = @body.unitscope
                                loc . unitdef = @body.unitdef

ATTR Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     FieldDeclaration FieldDeclarations RecordExpressionBinding RecordExpressionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression Type Types 
     MaybeUnit SimpleUnit Unit SimpleDimension
     RecordPatternBinding RecordPatternBindings 
     AnnotatedType AnnotatedTypes ContextItem ContextItems
     [ dscope, uscope : { Names } | | ]

-----------------------------------------------------------------------------

-- 3) Check if dimensions / units are in scope

ATTR Module Body Declarations Declaration
    Expressions Expression Patterns Pattern
    Statement Statements Qualifier Qualifiers
    Alternative Alternatives Constructor Constructors
    GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
    FieldDeclaration FieldDeclarations RecordExpressionBinding RecordExpressionBindings
    LeftHandSide RightHandSide MaybeDeclarations MaybeExpression Type Types 
    RecordPatternBinding RecordPatternBindings 
    AnnotatedType AnnotatedTypes ContextItem ContextItems
    MaybeUnit Unit SimpleUnit
    [ | | scopeunitError USE { ++ } { [] } : { [Error] } ]

ATTR Module Body Declarations Declaration
    Expressions Expression Patterns Pattern
    Statement Statements Qualifier Qualifiers
    Alternative Alternatives Constructor Constructors
    GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
    FieldDeclaration FieldDeclarations RecordExpressionBinding RecordExpressionBindings
    LeftHandSide RightHandSide MaybeDeclarations MaybeExpression Type Types 
    RecordPatternBinding RecordPatternBindings 
    AnnotatedType AnnotatedTypes ContextItem ContextItems
    SimpleDimension
    [ | | scopedimensionError USE { ++ } { [] } : { [Error] } ]

SEM Expression
    | Dimensioned               lhs . scopeunitError = @unit.scopeunitError

SEM SimpleUnit
    | SimpleUnit                lhs . scopeunitError =
                                    if not (@name.self `elem` @lhs.uscope) then
                                        [ Undefined Unit @name.self @lhs.uscope [] ]
                                    else [] -- [Undefined Unit @name.self @lhs.uscope []]

SEM SimpleDimension
    | SimpleDimension           lhs . scopedimensionError =
                                    if not (@name.self `elem` @lhs.dscope) then
                                        [ Undefined Dimension @name.self @lhs.dscope [] ]
                                    else [] -- [Undefined Dimension @name.self @lhs.dscope []]

-----------------------------------------------------------------------------

-- 4) Check if dimensions / units are duplicated

SEM Module
    | Module                    loc . unitdoublesError      = makeDuplicated Unit (filter ((>1) . length) . group . sort $ @uscope)
                                    . dimensiondoublesError = makeDuplicated Dimension (filter ((>1) . length) . group . sort $ @dscope)
                                    . recursiveUnitErrors =  if recursiveDependencies @unitdef then [RecursiveUnitDefinition []] else []
-----------------------------------------------------------------------------

{- 5) Detect cycles in the unit definition

SEM Module
  | Module   loc 
                -- if recursiveDependencies @unitdef then [RecursiveUnitDefinition []] else []-}


---------------------------------------------------------------------------

{
find_not_visited :: M.Map Name ([Name], Int) -> Maybe Name
find_not_visited visited =
    let lvisited = M.toList visited in
    (case find (\(_,(_,b)) -> b == 0) lvisited of
        Nothing -> Nothing
        Just (a,_) -> Just a)

hasCycle :: M.Map Name ([Name], Int) -> Bool
hasCycle visited =
        let name = find_not_visited visited in
        case name of
            Just n -> ccsearching visited [n]
            Nothing -> False
    where
        ccsearching :: M.Map Name ([Name], Int) -> [Name] -> Bool
        ccsearching visited stack_search =
            case stack_search of
                [] ->
                    let visited' = M.map ( \(l,b) -> (l, if b == 1 then 2 else b) ) visited in
                    case find_not_visited visited' of
                        Nothing -> False
                        Just newname -> ccsearching visited' [newname]
                name:q -> 
                    let (l, b) = case M.lookup name visited of Just a -> a in
                    if b==1 then True
                    else if b == 2 then
                        ccsearching visited q
                    else
                        let visited' = M.adjust (\(l,_) -> (l,1)) name visited in
                        ccsearching visited' (l++q)

removeDoubles :: Ord a => [a] -> [a]
removeDoubles =
    (map head) . group . sort

getName :: SimpleUnit -> Name
getName (SimpleUnit_SimpleUnit _ n) = n

getUnitDependencies :: Unit -> [Name]
getUnitDependencies unit =
    case unit of
        Unit_One _             -> []
        Unit_Variable _ _      -> []
        Unit_Base _ su         -> [getName su]
        Unit_Power _ u _       -> getUnitDependencies u
        Unit_NegPower _ u _    -> getUnitDependencies u
        Unit_Parenthesized _ u -> getUnitDependencies u
        Unit_Times _ ul ur     -> (getUnitDependencies ul) ++ (getUnitDependencies ur)
        Unit_Div _ ul ur       -> (getUnitDependencies ul) ++ (getUnitDependencies ur)

getDependencies :: Maybe Unit -> [Name]
getDependencies Nothing = []
getDependencies (Just u) = removeDoubles (getUnitDependencies u)

recursiveDependencies :: [(Name, Maybe Unit)] -> Bool
recursiveDependencies unitsdef =
    let unitgraph  = M.fromList [ (su,(l, 0)) | (su,u) <- unitsdef, let l = getDependencies u ] in
    hasCycle unitgraph
}