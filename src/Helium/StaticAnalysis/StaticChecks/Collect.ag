-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
--
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Collect the following information:
--
--    1) type constructors from a data type
--    2) type synonyms
--    3) (value) constructors from a data type
--    4) fixity declarations
--    5) record declarations
--
-- Distribute the collected environments
--    6) value constructors
--    7) type constructors
--    8) type synonyms

-- Collect the following information:
--    9) type classes and their declarations
-------------------------------------------------------------------------------

imports{
import Data.Maybe
}

SEM Module
  | Module   loc . collectEnvironment = setValueConstructors   (M.fromList  @body.collectValueConstructors)
                                        . setTypeConstructors  (M.fromList @body.collectTypeConstructors)
                                        . setTypeSynonyms      (M.fromList @body.collectTypeSynonyms)
                                        . setOperatorTable     (M.fromList @body.operatorFixities)
                                        . addToTypeEnvironment  (insertClassMembers @body.collectClassMemberEnv (M.fromList @derivedFunctions))
                                        . setClassEnvironment (insertInstances @body.classInstances
                                            (M.unionWith combineClassDecls @body.classEnv (classEnvironment $ combineImportEnvironmentList @lhs.importEnvironments)))
                                        . setInstanceEnvironment @body.instanceEnv
                                        . setClassMemberEnvironment @body.collectClassMemberEnv
                                        . setRecordEnvironment @body.collectRecord
                                        $emptyEnvironment
                                        -- the type environment will be added after type inferencing.
                 . derivedFunctions = [] ++ traceShowId @selectorFunctions
                 . selectorFunctions = map (\(n, (_, _, ts)) -> (n, ts)) $ concatMap M.assocs (M.elems @body.collectRecord)

{-
                 . derivedInstances = let f (n,i) = makeInstance "Show" i (show n)
                                          g (n,(i,_)) = f (n,i)
                                      in unitFM "Show"
                                            ( []
                                            , map f @body.collectTypeConstructors ++
                                              map g @body.collectTypeSynonyms
                                            )

-}

-------------------------------------------
-- 1) Collecting (data-)type constructors

ATTR Body Declarations Declaration [ | collectTypeConstructors : {[(Name,Int)]} | ]

SEM Module | Module   body . collectTypeConstructors = []

SEM Declaration
  | Data   lhs . collectTypeConstructors = (@simpletype.name,length @simpletype.typevariables) : @lhs.collectTypeConstructors

-------------------------------------------
-- 2) Collecting value constructors

ATTR Body Declarations Declaration Constructors Constructor [ | collectValueConstructors : {[(Name,TpScheme)]} | ]
ATTR Constructor Constructors [ | | parameterTypes USE { ++ } { [] } : Tps ]

SEM Module | Module   body . collectValueConstructors = []

SEM Constructor
  | Constructor
       lhs . collectValueConstructors = (@constructor.self, @typeScheme) : @lhs.collectValueConstructors
           . parameterTypes = @tps
       loc . typeScheme = generalizeAll ([] .=>. foldr (.->.) @tp @tps)
           . (tp,tps)   = convertFromSimpleTypeAndTypes @lhs.simpletype @types.types

  | Infix
       lhs . collectValueConstructors = (@constructorOperator.self, @typeScheme) : @lhs.collectValueConstructors
           . parameterTypes = @tps
       loc . typeScheme = generalizeAll ([] .=>. foldr (.->.) @tp @tps)
           . (tp,tps)   = convertFromSimpleTypeAndTypes @lhs.simpletype [@leftType.type,@rightType.type]

  | Record
       lhs . collectValueConstructors = (@constructor.self, @typeScheme) : @lhs.collectValueConstructors
           . parameterTypes = @tps
       loc . typeScheme = generalizeAll ([] .=>. foldr (.->.) @tp @tps)
           . (tp,tps)   = convertFromSimpleTypeAndTypes @lhs.simpletype @fieldDeclarations.types

-------------------------------------------
-- 3) Collecting type synonyms

ATTR Body Declarations Declaration [ | collectTypeSynonyms : {[(Name,(Int,Tps -> Tp))]} | ]

SEM Module | Module   body . collectTypeSynonyms = []

SEM Declaration
  | Type   lhs . collectTypeSynonyms = (@simpletype.name, @typeSynonymInfo) : @lhs.collectTypeSynonyms
           loc . typeSynonymInfo = (length @simpletype.typevariables,\tps -> makeTpFromType (zip @simpletype.typevariables tps) @type.self)

-------------------------------------------
-- 4) Collecting Fixity Declarations

ATTR Body Declarations Declaration MaybeDeclarations [ |  operatorFixities : {[(Name,(Int,Assoc))]} | ]

SEM Module | Module   body . operatorFixities = []


SEM MaybeDeclarations
    | Just
        lhs . operatorFixities = @declarations.operatorFixities

SEM Declaration
  | Fixity   lhs . operatorFixities = let associativity = case @fixity.self of
                                                             Fixity_Infix _  -> AssocNone
                                                             Fixity_Infixl _ -> AssocLeft
                                                             Fixity_Infixr _ -> AssocRight
                                          priority      = case @priority.self of
                                                             MaybeInt_Just i  -> i
                                                             MaybeInt_Nothing -> 9
                                      in [ (name, (priority, associativity)) | name <- @operators.self ] ++ @lhs.operatorFixities
    | Class lhs . operatorFixities = @where.operatorFixities

-------------------------------------------
-- 5) Collecting Record Declarations
-- 
-- Collects the positions of each of the labels within their respective constructors t
-- to determine how updates and constructions should be desugared.
-- 
-- Will collect them in the form of (constructors, (field, typeAndPosition))
-- 

ATTR Module Body Declarations Declaration Constructor Constructors [ | 
  | duplicateLabelsWrongTypes USE { M.unionWith (++) } { M.empty } : {M.Map Name [(Int, Tp)]}]
ATTR Body Declarations Declaration Constructor Constructors [ | 
  | collectRecord USE { M.union } { M.empty } : { M.Map Name (M.Map Name (Int, Tp, TpScheme)) } ]
ATTR FieldDeclarations [ | | collectFields USE { M.union } { M.empty } : { M.Map Name (Int, Tp, TpScheme) } ]
ATTR FieldDeclaration [ | | fieldSel : { [(Name, Tp, TpScheme)] } ]

SEM Declaration 
    | Data
        lhs . duplicateLabelsWrongTypes = M.filter (\xs -> length (nub xs) > 1) @allConFields
        loc . allConFields = let removeTps (i, t, _) = (i, t) 
                              in M.unionsWith (++) $ map (M.map ((:[]) . removeTps)) (M.elems @constructors.collectRecord)

SEM Constructor
    -- TODO: SEE IF THIS IS NECESSARY
    -- | Constructor lhs . collectRecord = M.singleton @constructor.self M.empty
    | Record
        lhs . collectRecord = M.singleton @constructor.self @fieldDeclarations.collectFields

SEM FieldDeclarations
    | Cons   
        lhs . collectFields = @loc.current `M.union` M.map (\(i, t, ts) -> (i + length @loc.current, t, ts)) @tl.collectFields
        loc . current = M.fromList $ map (\((n, t, ts), i) -> (n, (i, t, ts))) (zip @hd.fieldSel [0..])
    | Nil 
        lhs . collectFields = M.empty

SEM FieldDeclaration
    | FieldDeclaration 
        lhs . fieldSel = map (\n -> (n, @fieldType, @selectorType)) @names.self
        loc . fieldType = makeTpFromType' @type.type
            . (tp, tps) = convertFromSimpleTypeAndTypes @lhs.simpletype [@type.type]
            . selectorType = generalizeAll ([] .=>. foldl (.->.) @tp @tps)

ATTR Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     FieldDeclaration FieldDeclarations RecordExpressionBinding RecordExpressionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression Type Types 
     AnnotatedType AnnotatedTypes ContextItem ContextItems
     [ recordFields : {M.Map Name (M.Map Name (Int, Tp, TpScheme))} | | ]

SEM Module
    | Module body.recordFields = @body.collectRecord

-------------------------------------------
-- 6) Distributing Value Constructors

SEM Module
  | Module   loc . (uniqueValueConstructors, duplicatedValueConstructors) =
                      uniqueKeys (  @body.collectValueConstructors
                                 ++ concatMap (M.assocs . valueConstructors) @lhs.importEnvironments
                                 )
                 . allValueConstructors = map fst @uniqueValueConstructors ++ map head @duplicatedValueConstructors
                 . valueConstructors    = M.fromList @uniqueValueConstructors

ATTR Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     FieldDeclaration FieldDeclarations RecordExpressionBinding RecordExpressionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression 
     AnnotatedType AnnotatedTypes
     [ valueConstructors : {M.Map Name TpScheme} allValueConstructors : Names | | ]

-------------------------------------------
-- 7) Distributing Type Constructors

SEM Module
  | Module loc . (uniqueTypeConstructors,duplicatedTypeConstructors) =
                    uniqueKeys (  @body.collectTypeConstructors
                               ++ concatMap (M.assocs . typeConstructors) @lhs.importEnvironments
                               ++ [ (n,i) | (n,(i,_)) <- @body.collectTypeSynonyms ]
                               )
               . allTypeConstructors = map fst @uniqueTypeConstructors ++ map head @duplicatedTypeConstructors
               . typeConstructors    = M.fromList @uniqueTypeConstructors

ATTR Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     FieldDeclaration FieldDeclarations RecordExpressionBinding RecordExpressionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression Type Types 
     AnnotatedType AnnotatedTypes ContextItem ContextItems
     [ typeConstructors : {M.Map Name Int} allTypeConstructors : Names | | ]

-------------------------------------------
-- 8) Distributing Type Synonyms

ATTR Module -> Declaration [ orderedTypeSynonyms:OrderedTypeSynonyms | | ]

SEM Module
  | Module body . orderedTypeSynonyms =
                      let list     = concatMap (M.assocs . typeSynonyms) @lhs.importEnvironments ++
                                     @body.collectTypeSynonyms
                          newmap   = M.fromList [ (show name, t) | (name, t) <- list ]
                          ordering = fst (getTypeSynonymOrdering newmap)
                      in (ordering, newmap)

--------------------------------
-- Derived instances (see also TypeInferenceCollect.ag)

ATTR Module -> Declaration [ classEnvironment:ClassEnvironment | | collectInstances USE { ++ } { [] } : {[(Name, Instance)]} ]

SEM Module
  | Module
       body.classEnvironment =
          let importEnv = foldr combineImportEnvironments emptyEnvironment @lhs.importEnvironments
          in foldr (\(n, i) -> insertInstance (show n) i)
                   (classEnvironment importEnv)
                   @body.collectInstances

SEM Declaration
  | Data
       lhs . collectInstances = [ (cl, makeInstance (show cl) (length @simpletype.typevariables) (show @simpletype.name) True)
                                | cl <- @derivings.self
                                ]


-------------------------------------------------------
-- utility attributes for types and constructors

ATTR SimpleType [ | | name:Name typevariables:Names ]

SEM SimpleType
  | SimpleType  lhs . name          = @name.self
                    . typevariables = @typevariables.self

ATTR Type Types AnnotatedTypes AnnotatedType Constructors Constructor 
  FieldDeclarations FieldDeclaration [ | | typevariables USE { ++ } { [] } : Names ]

SEM Type
  | Variable  lhs . typevariables = [ @name.self ]

ATTR Constructors Constructor FieldDeclaration FieldDeclarations [ simpletype:SimpleType | | ]

SEM Declaration
  | Data     constructors . simpletype = @simpletype.self
  | Newtype  constructor  . simpletype = @simpletype.self

ATTR AnnotatedTypes FieldDeclarations [ | | types : Types ]
ATTR AnnotatedType FieldDeclaration  [ | | type  : Type  ]

SEM AnnotatedTypes
  | Cons   lhs . types = @hd.type : @tl.types
  | Nil    lhs . types = []

SEM AnnotatedType
  | AnnotatedType  lhs . type = @type.self

SEM FieldDeclarations
  | Cons   lhs . types = @hd.type : @tl.types
  | Nil    lhs . types = []

SEM FieldDeclaration
  | FieldDeclaration  lhs . type = @type.type

{
uniqueKeys :: Ord key => [(key,a)] -> ([(key,a)],[[key]])
uniqueKeys = let comp (x,_) (y,_) = compare x y
                 eq   (x,_) (y,_) = x == y
                 predicate xs = length xs == 1
             in (\(xs, ys) -> (map head xs, map (map fst) ys))
              . partition predicate
              . groupBy eq
              . sortBy comp
}

-- Collecting the Classes
{


-- The following haskell code is used for building a temporary dictionairy in order to complete static checks
type ClassDef = (Name, ClassMembers)
type ClassMembers = (Names, [(Name, TpScheme, Bool, HasDefault)])
type ClassMembers' = [(Name, TpScheme, Bool, HasDefault)]

--In declarations we find both type signatures and function declarations
filterType :: Declarations -> (Declarations, Declarations) -> (Declarations, Declarations)
filterType (d@(Declaration_TypeSignature _ _ _):ds) (t, dec) = filterType ds (d:t, dec)
filterType (d:ds) (t, dec)                                   = filterType ds (t, d:dec)
filterType []     res                                        = res


reorderQuantors :: Names -> TpScheme -> TpScheme
reorderQuantors firstQuantors ty1@(Quantification (quantors, qmap, tp)) =
  Quantification (quantors', qmap, tp)
  where
    quantors' = map fst (mapMaybe (\name -> find ((getNameName name == ) . snd) qmap) firstQuantors)
      ++ filter notInFirst quantors
    notInFirst idx = case lookup idx qmap of
      Nothing -> True
      Just str -> all (\name -> getNameName name /= str) firstQuantors

--A type can be declared for multiple function names
createClassDef1 :: Names -> Declaration -> ClassMembers'
createClassDef1 typeArgs (Declaration_TypeSignature _ names ty) = [(n, reorderQuantors typeArgs $ fst $ makeTpSchemeFromType' ty, False, False) | n <- names]
createClassDef1 _ _ = error "Error createClassDef1, filtering failed..."

--A function declaration should be associated with a type in the class definition
createClassDef2 :: Declarations -> ClassMembers' -> ClassMembers'
createClassDef2 (d:ds) m = createClassDef2 ds $ createClassDef2' (nameOfDeclaration d) d m
createClassDef2 []     m = m

createClassDef2' :: Eq t1 => [t1] -> t -> [(t1, TpScheme, Bool, HasDefault)] -> [(t1, TpScheme, Bool, HasDefault)]
createClassDef2' (n:ns) d m = createClassDef2' ns d $ createClassDef2'' n d m
createClassDef2' []     _ m = m


createClassDef2'' :: Eq t1 => t1 -> t -> [(t1, TpScheme, Bool, HasDefault)] -> [(t1, TpScheme, Bool, HasDefault)]
createClassDef2'' n d (m@(n2,t, _, def):ms) | n == n2   = (n2, t, True, def):ms
                                     | otherwise = m:(createClassDef2'' n d ms)
createClassDef2'' _ _ []                             = [] -- Should not happen but if it happens the error is reported by another check

createClassDef :: Name -> MaybeDeclarations -> Names -> ClassMemberEnvironment
createClassDef n MaybeDeclarations_Nothing names  = M.singleton n (names, [])
createClassDef n (MaybeDeclarations_Just decls) names = M.singleton n (names, createClassDef2 fdecl $ concatMap (createClassDef1 names) types)
               where (types, fdecl) = filterType decls ([], [])

insertDefaults :: Name -> Names -> ClassMemberEnvironment -> ClassMemberEnvironment
insertDefaults name defs env = M.mapWithKey (\n membs -> if n == name then (update defs membs) else membs) env 
      where
          update :: Names -> (Names, [(Name, TpScheme, Bool, HasDefault)]) -> (Names, [(Name, TpScheme, Bool, HasDefault)])
          update defs (tvars, funcs) = (tvars, map (\(fname, tpscheme, b, _)->(fname, tpscheme, b, fname `elem` defs)) funcs)

insertInstances :: [(String, Tp, [(String, Tp)])] -> ClassEnvironment -> ClassEnvironment
insertInstances instances classEnv = foldr (\inst@(n, _, _) -> M.update (insert inst) n) classEnv instances
    where
        insert :: (String, Tp, [(String, Tp)]) -> Class -> Maybe Class
        insert (className, instType, preds) (cn, instances) = 
            let 
               curInstance = (Predicate className instType, [Predicate n v | (n, v) <- preds]) 
            in Just (cn, nub $ curInstance : instances)

insertClassMembers :: M.Map Name (Names, [(Name, TpScheme, Bool, HasDefault)]) -> M.Map Name TpScheme -> M.Map Name TpScheme
insertClassMembers classMemberEnv valueEnv = M.foldrWithKey insert valueEnv classMemberEnv
    where 
        insert :: Name -> (Names, [(Name, TpScheme, Bool, HasDefault)]) -> M.Map Name TpScheme -> M.Map Name TpScheme
        insert className (typeVars, funcs) env = foldr (insertFunc className typeVars)  env funcs
        insertFunc :: Name -> Names -> (Name, TpScheme, Bool, HasDefault) -> M.Map Name TpScheme -> M.Map Name TpScheme
        insertFunc className typeVars (name, tp, _, _) env = 
            let 
                typeIndices :: [(Int, String)]
                typeIndices = filter (\(_, s) -> s `elem` (map getNameName typeVars)) (getQuantorMap tp)
                typeVariablesMapped = map (\(n, s) -> (fromJust $ find (\tv -> getNameName tv == s) typeVars, TVar n)) typeIndices
                tpWContext = addContextToType className typeVariablesMapped tp
            in M.insert name tpWContext env
}

ATTR Declarations Declaration [ | | collectTypeClasses  USE { ++ } { [] } : { [(Name, [(Name, TpScheme)])] } ]
ATTR Body Declarations Declaration [ | | collectClassMemberEnv USE { `M.union` } { M.empty } : {ClassMemberEnvironment} ]

SEM Module
    | Module body . classMemberEnv = foldr M.union @body.collectClassMemberEnv (map classMemberEnvironment @lhs.importEnvironments)

SEM Declaration
    | Class lhs . collectTypeClasses = [(@simpletype.name, @where.typeSignatures)]
            lhs . collectClassMemberEnv = insertDefaults @simpletype.name @where.functionDefaults $ createClassDef @simpletype.name @where.self @simpletype.typevariables

SEM Declarations
    | Cons     lhs . collectTypeClasses = @hd.collectTypeClasses  ++ @tl.collectTypeClasses

-- Collect the type variables in the context
ATTR ContextItems ContextItem [ || typeVariables USE {++} {[]} : Types ]

SEM ContextItem
     | ContextItem lhs . typeVariables = @types.self

-------------------------------------------
-- Collecting Type Signatures

ATTR Declaration Declarations [ | typeSignatures:{[(Name,TpScheme)]} | ]
ATTR Body MaybeDeclarations   [ | | typeSignatures:{[(Name,TpScheme)]} ]
ATTR Declaration Declarations MaybeDeclarations [ | | functionDefaults USE {(++)} {[]} : {[Name]}]

SEM Body
  | Hole lhs . typeSignatures = []
  | Body    declarations . typeSignatures = []
SEM Expression        | Let     declarations . typeSignatures = []
SEM Statement         | Let     declarations . typeSignatures = []
SEM Qualifier         | Let     declarations . typeSignatures = []
SEM MaybeDeclarations | Just    declarations . typeSignatures = []
                      | Nothing lhs          . typeSignatures = []


SEM Declaration
  | TypeSignature
      lhs . typeSignatures = [ (name, @typeScheme) | name <- @names.self ] ++ @lhs.typeSignatures
      loc . (typeScheme, intMap) = makeTpSchemeFromType' @type.self
  | Class
      --lhs . typeSignatures = [] --@where.typeSignatures
  | Instance
      lhs . typeSignatures = @where.typeSignatures -- And we apply the same trick again
  | FunctionBindings
      lhs . functionDefaults = [@bindings.name]

-------
-- Building a Class Environment

ATTR Body [ importedClassEnv : {ClassEnvironment}| | ]

SEM Module
  | Module body . importedClassEnv = classEnvironment $ combineImportEnvironmentList @lhs.importEnvironments

ATTR Body Declaration Declarations [
    |
    |
        classEnv USE {`M.union`} {M.empty} : {ClassEnvironment}
        instanceEnv USE {`M.union`} {M.empty} : {InstanceEnvironment}
        classInstances USE {(++)} {[]} : {[(String, Tp, [(String, Tp)])]}
]

SEM Declaration
    | Class
        lhs . classEnv = M.singleton (getClassName @simpletype.self) ((map fst $ getSuperClasses @context.self), [])
    | Instance
       lhs . classInstances = let
                                superClasses :: [(String, Tp)]
                                superClasses = map (\(c, tpss)-> (c, unqualify $ unquantify $ head tpss)) $ getSuperClasses @context.self
                              in [(getNameName $ @name.self, makeTpFromType' $ head @types.self, superClasses)] 

       lhs . instanceEnv = M.singleton (@name.self, makeTpFromType' $ head @types.self) (namesInType (head @types.self), map (\(n, tp) -> (n, show $ head tp)) $ getSuperClasses @context.self)
    | Data  lhs . instanceEnv = M.fromList 
                                    [
                                        let className = dn
                                            dataName = @simpletype.name
                                            tvs = @simpletype.typevariables
                                            tVars = zip tvs (map TVar [0..])
                                            key = (dn, foldl TApp (TCon $ show dataName) $ map snd tVars)
                                            value = (tvs, [(show dn, tv) | tv <- map show tvs])
                                        in (key, value) | dn <- @derivings.self
                                    ]
            lhs . classInstances =  [
                                        let 
                                            tvs = @simpletype.typevariables
                                            tVars = zip tvs (map TVar [0..])
                                            typeClass = foldl TApp (TCon $ show @simpletype.name) $ map snd tVars
                                        in (show dn, typeClass, map (\x -> (show dn, snd x)) tVars)
                                        | dn <- @derivings.self
                                    ]
        
{

getTypeOfInstanceFunction :: Name -> Name -> ClassMemberEnvironment -> TpScheme
getTypeOfInstanceFunction instanceName name env = case M.lookup instanceName env of
        Just c ->   let (_, functions) = c
                        (_, tp, _, _) = fromMaybe (error "Unknown function in instance") (lookupFunc name functions)
                    in tp
        Nothing -> error "Unknown class in instance declaration"
    where
        lookupFunc :: Name -> [(Name, a, b, c)] -> Maybe (Name, a, b, c)
        lookupFunc _ [] = Nothing
        lookupFunc n (f@(nf, _, _, _):fs)  | n == nf   = Just f
                                        | otherwise = lookupFunc n fs

getClassName :: SimpleType -> String
getClassName (SimpleType_SimpleType _ n _) = getNameName n

getSuperClasses ::  ContextItems -> [(String, [TpScheme])]
getSuperClasses = map (\(ContextItem_ContextItem _ n vs) -> (getNameName n, (map makeTpSchemeFromType vs)))

getInstanceFunctionNames :: MaybeDeclarations -> [Name]
getInstanceFunctionNames (MaybeDeclarations_Nothing) = []
getInstanceFunctionNames (MaybeDeclarations_Just ds) = fmap (\d -> getDeclarationName d) ds

getDeclarationName :: Declaration -> Name
getDeclarationName (Declaration_FunctionBindings _ []) = error "No function bindings found" 
getDeclarationName (Declaration_FunctionBindings _ [fb]) = getFunctionBindingName fb
getDeclarationName (Declaration_FunctionBindings _ fb) =
        let names = map getFunctionBindingName fb 
            valid = all (==(head names)) names
        in if valid then head names else error "Inconsistent names in function bindings"

getDeclarationName _ = error $ "Unknown declaration in instance"

getFunctionBindingName :: FunctionBinding -> Name
getFunctionBindingName (FunctionBinding_FunctionBinding _ lhs _)= getLhsName lhs

getLhsName :: LeftHandSide -> Name
getLhsName (LeftHandSide_Function _ name _) = name
getLhsName (LeftHandSide_Infix _ _ name _) = name
}

ATTR Body Declaration Declarations [ | | instances USE {++} {[]} : {[(Range, Instance)]} ]

SEM Declaration
  | Instance
     lhs . instances = [createInstance @range.self @name.self (head @types.self) @context.self]
  | Data
    lhs. instances = [ (@range.self, makeInstance (show cl) (length @simpletype.typevariables) (show @simpletype.name) True)
                                | cl <- @derivings.self
                                ]
    

{

createInstance :: Range -> Name -> Type -> ContextItems -> (Range, Instance)
createInstance r n ty ctx = (r, (makePredicate n ty , map (\(ContextItem_ContextItem _ n2 tys) -> makePredicate n2 (head tys)) ctx))
   where nameMap = makeNameMap (namesInTypes $ ty : (map (\(ContextItem_ContextItem _ _ tys) -> head tys) ctx))
         makePredicate :: Name -> Type -> Predicate
         makePredicate nm typ = Predicate (getNameName nm) (makeTpFromType nameMap typ)

}
