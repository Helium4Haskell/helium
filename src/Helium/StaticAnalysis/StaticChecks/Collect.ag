-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
--
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Collect the following information:
--
--    1) type constructors from a data type
--    2) type synonyms
--    3) (value) constructors from a data type
--    4) fixity declarations
--
-- Distribute the collected environments
--    5) value constructors
--    6) type constructors
--    7) type synonyms

-- Collect the following information:
--    8) type classes and their declarations
-------------------------------------------------------------------------------

imports{
import Data.Maybe
import Control.Arrow
}

SEM Module
  | Module   loc . collectEnvironment = setValueConstructors   (M.fromList @body.collectValueConstructors)
                                        . setTypeConstructors  (M.fromList @body.collectTypeConstructors)
                                        . setTypeSynonyms      (M.fromList @body.collectTypeSynonyms)
                                        . setOperatorTable     (M.fromList @body.operatorFixities)
                                        . addToTypeEnvironment  (insertClassMembers @body.collectClassMemberEnv (M.fromList @derivedFunctions))
                                        . setClassEnvironment (insertInstances @body.classInstances
                                            (M.unionWith combineClassDecls @body.classEnv (classEnvironment $ combineImportEnvironmentList @lhs.importEnvironments)))
                                        . setInstanceEnvironment @body.instanceEnv
                                        . setClassMemberEnvironment @body.collectClassMemberEnv
                                        $ emptyEnvironment
                                        -- the type environment will be added after type inferencing.
                 . derivedFunctions = []

{-
                 . derivedInstances = let f (n,i) = makeInstance "Show" i (show n)
                                          g (n,(i,_)) = f (n,i)
                                      in unitFM "Show"
                                            ( []
                                            , map f @body.collectTypeConstructors ++
                                              map g @body.collectTypeSynonyms
                                            )

-}

-------------------------------------------
-- 1) Collecting (data-)type constructors

ATTR Body Declarations Declaration [ | collectTypeConstructors : {[(Name,Int)]} | ]

SEM Module | Module   body . collectTypeConstructors = []

SEM Declaration
  | Data        lhs . collectTypeConstructors = (@simpletype.name,length @simpletype.typevariables) : @lhs.collectTypeConstructors
  | Data_Gadt   lhs . collectTypeConstructors = (@simpletype.name, length @simpletype.typevariables) : @lhs.collectTypeConstructors
                constructors . returnType   = datatypeToTpScheme @simpletype.name @simpletype.typevariables

-------------------------------------------
-- 2) Collecting value constructors

ATTR Body Declarations Declaration Constructors Constructor [ 
    | collectValueConstructors : {[(Name, (TpScheme, ConstructorType))]} 
    | incorrectReturnTypeErrors USE {(++)} {[]}  : {[Error]} 
    ]
ATTR Constructor Constructors [ returnType : TpScheme | | parameterTypes USE { ++ } { [] } : Tps ]

SEM Module | Module   body . collectValueConstructors = []

SEM Constructor
  | Constructor
       lhs . collectValueConstructors = (@constructor.self, (@typeScheme, ConstructorRegular)) : @lhs.collectValueConstructors
           . parameterTypes = @tps
       loc . typeScheme = generalizeAll ([] .=>. foldr (.->.) @tp @tps)
           . (tp,tps)   = convertFromSimpleTypeAndTypes @lhs.simpletype @types.types

  | Infix
       lhs . collectValueConstructors = (@constructorOperator.self, (@typeScheme, ConstructorRegular)) : @lhs.collectValueConstructors
           . parameterTypes = @tps
       loc . typeScheme = generalizeAll ([] .=>. foldr (.->.) @tp @tps)
           . (tp,tps)   = convertFromSimpleTypeAndTypes @lhs.simpletype [@leftType.type,@rightType.type]
   | GADT 
        lhs . collectValueConstructors = (@constructor.self, (@typeScheme, ConstructorGADT)) : @lhs.collectValueConstructors
        loc . typeScheme                = makeTpSchemeFromType @type.self
        lhs . incorrectReturnTypeErrors = [IncorrectConstructorResult @range.self @constructor.self @typeScheme @lhs.returnType | not $ matchReturnType @typeScheme @lhs.returnType]

-------------------------------------------
-- 3) Collecting type synonyms

ATTR Body Declarations Declaration [ | collectTypeSynonyms : {[(Name,(Int,Tps -> Tp))]} | ]

SEM Module | Module   body . collectTypeSynonyms = []

SEM Declaration
  | Type   lhs . collectTypeSynonyms = (@simpletype.name, @typeSynonymInfo) : @lhs.collectTypeSynonyms
           loc . typeSynonymInfo = (length @simpletype.typevariables,\tps -> makeTpFromType (zip @simpletype.typevariables tps) @type.self)

-------------------------------------------
-- 4) Collecting Fixity Declarations

ATTR Body Declarations Declaration MaybeDeclarations [ |  operatorFixities : {[(Name,(Int,Assoc))]} | ]

SEM Module | Module   body . operatorFixities = []


SEM MaybeDeclarations
    | Just
        lhs . operatorFixities = @declarations.operatorFixities

SEM Declaration
  | Fixity   lhs . operatorFixities = let associativity = case @fixity.self of
                                                             Fixity_Infix _  -> AssocNone
                                                             Fixity_Infixl _ -> AssocLeft
                                                             Fixity_Infixr _ -> AssocRight
                                          priority      = case @priority.self of
                                                             MaybeInt_Just i  -> i
                                                             MaybeInt_Nothing -> 9
                                      in [ (name, (priority, associativity)) | name <- @operators.self ] ++ @lhs.operatorFixities
    | Class lhs . operatorFixities = @where.operatorFixities

-------------------------------------------
-- 5) Distributing Value Constructors

SEM Module
  | Module   loc . (uniqueValueConstructors,duplicatedValueConstructors) =
                      uniqueKeys (  @body.collectValueConstructors
                                 ++ concatMap (M.assocs . valueConstructors) @lhs.importEnvironments
                                 )
                 . allValueConstructors = map fst @uniqueValueConstructors ++ map head @duplicatedValueConstructors
                 . valueConstructors    = M.map fst $ M.fromList @uniqueValueConstructors

ATTR Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression AnnotatedType AnnotatedTypes
     [ valueConstructors : {M.Map Name TpScheme} allValueConstructors : Names | | ]

-------------------------------------------
-- 6) Distributing Type Constructors

SEM Module
  | Module loc . (uniqueTypeConstructors,duplicatedTypeConstructors) =
                    uniqueKeys (  @body.collectTypeConstructors
                               ++ concatMap (M.assocs . typeConstructors) @lhs.importEnvironments
                               ++ [ (n,i) | (n,(i,_)) <- @body.collectTypeSynonyms ]
                               )
               . allTypeConstructors = map fst @uniqueTypeConstructors ++ map head @duplicatedTypeConstructors
               . typeConstructors    = M.fromList @uniqueTypeConstructors

ATTR Body Declarations Declaration Expressions Expression Patterns Pattern
     Statement Statements Qualifier Qualifiers
     Alternative Alternatives Constructor Constructors
     GuardedExpressions GuardedExpression FunctionBinding FunctionBindings
     LeftHandSide RightHandSide MaybeDeclarations MaybeExpression
     Type Types AnnotatedType AnnotatedTypes ContextItem ContextItems
     [ typeConstructors : {M.Map Name Int} allTypeConstructors : Names | | ]

-------------------------------------------
-- 7) Distributing Type Synonyms

ATTR Module -> Declaration [ orderedTypeSynonyms:OrderedTypeSynonyms | | ]

SEM Module
  | Module body . orderedTypeSynonyms =
                      let list     = concatMap (M.assocs . typeSynonyms) @lhs.importEnvironments ++
                                     @body.collectTypeSynonyms
                          newmap   = M.fromList [ (show name, t) | (name, t) <- list ]
                          ordering = fst (getTypeSynonymOrdering newmap)
                      in (ordering, newmap)

--------------------------------
-- Derived instances (see also TypeInferenceCollect.ag)

ATTR Module -> Declaration [ classEnvironment:ClassEnvironment | | collectInstances USE { ++ } { [] } : {[(Name, Instance)]} ]

SEM Module
  | Module
       body.classEnvironment =
          let importEnv = foldr combineImportEnvironments emptyEnvironment @lhs.importEnvironments
          in foldr (\(n, i) -> insertInstance (show n) i)
                   (classEnvironment importEnv)
                   @body.collectInstances

SEM Declaration
  | Data
       lhs . collectInstances = [ (cl, makeInstance (show cl) (length @simpletype.typevariables) (show @simpletype.name) True)
                                | cl <- @derivings.self
                                ]


-------------------------------------------------------
-- utility attributes for types and constructors

ATTR SimpleType [ | | name:Name typevariables:Names ]

SEM SimpleType
  | SimpleType  lhs . name          = @name.self
                    . typevariables = @typevariables.self

ATTR Type Types AnnotatedTypes AnnotatedType Constructors Constructor [ | | typevariables USE { ++ } { [] } : Names ]

SEM Type
  | Variable  lhs . typevariables = [ @name.self ]

ATTR Constructors Constructor [ simpletype:SimpleType | | ]

SEM Declaration
  | Data        constructors . simpletype = @simpletype.self
  | Data_Gadt   constructors . simpletype = @simpletype.self
  | Newtype     constructor  . simpletype = @simpletype.self

ATTR AnnotatedTypes [ | | types : Types ]
ATTR AnnotatedType  [ | | type  : Type  ]

SEM AnnotatedTypes
  | Cons   lhs . types = @hd.type : @tl.types
  | Nil    lhs . types = []

SEM AnnotatedType
  | AnnotatedType  lhs . type = @type.self

{
uniqueKeys :: Ord key => [(key,a)] -> ([(key,a)],[[key]])
uniqueKeys = let comp (x,_) (y,_) = compare x y
                 eq   (x,_) (y,_) = x == y
                 predicate xs = length xs == 1
             in (\(xs, ys) -> (map head xs, map (map fst) ys))
              . partition predicate
              . groupBy eq
              . sortBy comp
}

-- Collecting the Classes and TypeFamilies.
{


-- The following haskell code is used for building a temporary dictionairy in order to complete static checks
type ClassDef = (Name, ClassMembers)
type ClassMembers = (Names, [(Name, TpScheme, Bool, HasDefault)])
type ClassMembers' = [(Name, TpScheme, Bool, HasDefault)]

--In declarations we find both type signatures and function declarations
filterType :: Declarations -> (Declarations, Declarations) -> (Declarations, Declarations)
filterType (d@(Declaration_TypeSignature _ _ _):ds) (t, dec) = filterType ds (d:t, dec)
filterType (d@(Declaration_FunctionBindings{}):ds)  (t, dec) = filterType ds (t, d:dec)
filterType (_:ds)                                   (t, dec) = filterType ds (t, dec)
filterType []                                       res      = res

--A type can be declared for multiple function names
createClassDef1 :: Declaration -> ClassMembers'
createClassDef1 (Declaration_TypeSignature _ names ty) = [(n, fst $ makeTpSchemeFromType' ty, False, False) | n <- names]
createClassDef1 _                                     = error "Error createClassDef1, filtering failed..."

--A function declaration should be associated with a type in the class definition
createClassDef2 :: Declarations -> ClassMembers' -> ClassMembers'
createClassDef2 (d:ds) m = createClassDef2 ds $ createClassDef2' (nameOfDeclaration d) d m
createClassDef2 []     m = m

createClassDef2' :: Eq t1 => [t1] -> t -> [(t1, TpScheme, Bool, HasDefault)] -> [(t1, TpScheme, Bool, HasDefault)]
createClassDef2' (n:ns) d m = createClassDef2' ns d $ createClassDef2'' n d m
createClassDef2' []     _ m = m


createClassDef2'' :: Eq t1 => t1 -> t -> [(t1, TpScheme, Bool, HasDefault)] -> [(t1, TpScheme, Bool, HasDefault)]
createClassDef2'' n d (m@(n2,t, _, def):ms) | n == n2   = (n2, t, True, def):ms
                                     | otherwise = m:(createClassDef2'' n d ms)
createClassDef2'' _ _ []                             = [] -- Should not happen but if it happens the error is reported by another check

createClassDef :: Name -> MaybeDeclarations -> Names -> ClassMemberEnvironment
createClassDef n MaybeDeclarations_Nothing names  = M.singleton n (names, [])
createClassDef n (MaybeDeclarations_Just decls) names = M.singleton n (names, createClassDef2 fdecl $ concatMap createClassDef1 types)
               where (types, fdecl) = filterType decls ([], [])

insertDefaults :: Name -> Names -> ClassMemberEnvironment -> ClassMemberEnvironment
insertDefaults name defs env = M.mapWithKey (\n membs -> if n == name then (update defs membs) else membs) env 
      where
          update :: Names -> (Names, [(Name, TpScheme, Bool, HasDefault)]) -> (Names, [(Name, TpScheme, Bool, HasDefault)])
          update defs (tvars, funcs) = (tvars, map (\(fname, tpscheme, b, _)->(fname, tpscheme, b, fname `elem` defs)) funcs)

insertInstances :: [(String, Tp, [(String, Tp)])] -> ClassEnvironment -> ClassEnvironment
insertInstances instances classEnv = foldr (\inst@(n, _, _) -> M.update (insert inst) n) classEnv instances
    where
        insert :: (String, Tp, [(String, Tp)]) -> Class -> Maybe Class
        insert (className, instType, preds) (cn, instances) = 
            let 
               curInstance = (Predicate className instType, [Predicate n v | (n, v) <- preds]) 
            in Just (cn, nub $ curInstance : instances)

insertClassMembers :: M.Map Name (Names, [(Name, TpScheme, Bool, HasDefault)]) -> M.Map Name TpScheme -> M.Map Name TpScheme
insertClassMembers classMemberEnv valueEnv = M.foldrWithKey insert valueEnv classMemberEnv
    where 
        insert :: Name -> (Names, [(Name, TpScheme, Bool, HasDefault)]) -> M.Map Name TpScheme -> M.Map Name TpScheme
        insert className (typeVars, funcs) env = foldr (insertFunc className typeVars)  env funcs
        insertFunc :: Name -> Names -> (Name, TpScheme, Bool, HasDefault) -> M.Map Name TpScheme -> M.Map Name TpScheme
        insertFunc className typeVars (name, tp, _, _) env = 
            let 
                typeIndices :: [(Int, String)]
                typeIndices = filter (\(_, s) -> s `elem` (map getNameName typeVars)) (getQuantorMap tp)
                typeVariablesMapped = map (\(n, s) -> (fromJust $ find (\tv -> getNameName tv == s) typeVars, TVar n)) typeIndices
                tpWContext = addContextToType className typeVariablesMapped tp
            in M.insert name tpWContext env
}

ATTR Declarations Declaration [ | | collectTypeClasses  USE { ++ } { [] } : { [(Name, [(Name, TpScheme)])] } ]
ATTR Body Declarations Declaration [ | | collectClassMemberEnv USE { `M.union` } { M.empty } : {ClassMemberEnvironment} ]

SEM Module
    | Module body . classMemberEnv = foldr M.union @body.collectClassMemberEnv (map classMemberEnvironment @lhs.importEnvironments)

SEM Declaration
    | Class lhs . collectTypeClasses = [(@simpletype.name, @where.typeSignatures)]
            lhs . collectClassMemberEnv = insertDefaults @simpletype.name @where.functionDefaults $ createClassDef @simpletype.name @where.self @simpletype.typevariables

SEM Declarations
    | Cons     lhs . collectTypeClasses = @hd.collectTypeClasses  ++ @tl.collectTypeClasses

-- Collect the type variables in the context
ATTR ContextItems ContextItem [ || typeVariables USE {++} {[]} : Types ]

SEM ContextItem
     | ContextItem lhs . typeVariables = @types.self


-------------------------------------------
-- Collecting Type Family decls and instances

{
type Dummy = Int

-- Filter TF decls from others
collectTFDecls :: Declarations -> Declarations
collectTFDecls = filter isTFdecl
  where isTFdecl (Declaration_TypeFam{}) = True
        isTFdecl _                       = False

collectTFInstances :: Declarations -> Declarations
collectTFInstances = filter isTFinstance
  where isTFinstance (Declaration_TypeFamInstance{}) = True
        isTFinstance _                               = False

-- Collecting normal type fams decls and instances
collectTypeFamDecls :: Declaration -> TFDeclInfo
collectTypeFamDecls (Declaration_TypeFam _ (SimpleType_SimpleType _ n tv) MaybeInjectivity_Nothing MaybeDeclarations_Nothing)
  = DOpen n tv Nothing
collectTypeFamDecls (Declaration_TypeFam _ (SimpleType_SimpleType _ n tv) (MaybeInjectivity_Just inj) MaybeDeclarations_Nothing)
  = let (Injectivity_Injectivity _ _ ns) = inj in DOpen n tv (Just ns)
collectTypeFamDecls (Declaration_TypeFam _ (SimpleType_SimpleType _ n tv) MaybeInjectivity_Nothing _)
  = DClosed n tv Nothing
collectTypeFamDecls (Declaration_TypeFam _ (SimpleType_SimpleType _ n tv) (MaybeInjectivity_Just inj) _)
  = let (Injectivity_Injectivity _ _ ns) = inj in DClosed n tv (Just ns)

collectTypeFamInstance :: Declaration -> Int -> TFInstanceInfo
collectTypeFamInstance (Declaration_TypeFamInstance _ isClosed n ts t) instId
  = if isClosed
      then IClosed n ts t instId
      else IOpen n ts t

-- Collecting assoc type syns
collectAssocTypeSynDecls :: Declaration -> MaybeDeclarations -> TFDeclInfos
collectAssocTypeSynDecls _  MaybeDeclarations_Nothing = []
collectAssocTypeSynDecls cl (MaybeDeclarations_Just decls) = collectAssocTypeSynDecls' cl $ collectTFDecls decls

collectAssocTypeSynDecls' :: Declaration -> Declarations -> TFDeclInfos
collectAssocTypeSynDecls' cd@(Declaration_Class _ _ (SimpleType_SimpleType _ n tvs) _) (Declaration_TypeFam _ (SimpleType_SimpleType _ tfn tftvs) inj _:tfdls)
  = let
      injInfo = case inj of
                  MaybeInjectivity_Nothing -> Nothing
                  MaybeInjectivity_Just (Injectivity_Injectivity _ _ ns) -> Just ns
                  _ -> Nothing
      buildAssocIndices = [(fromJust (elemIndex tv tvs), fromJust (elemIndex tftv tftvs)) | tv <- tvs, tftv <- tftvs, tv == tftv]
      in DAssoc tfn tftvs injInfo buildAssocIndices n : collectAssocTypeSynDecls' cd tfdls
collectAssocTypeSynDecls' cd (_:decls) = collectAssocTypeSynDecls' cd decls
collectAssocTypeSynDecls' _  []        = []

collectAssocTypeSynInstances :: Declaration -> MaybeDeclarations -> TFInstanceInfos
collectAssocTypeSynInstances _ MaybeDeclarations_Nothing = []
collectAssocTypeSynInstances inst (MaybeDeclarations_Just decls) = collectAssocTypeSynInstances' inst decls

collectAssocTypeSynInstances' :: Declaration -> Declarations -> TFInstanceInfos
collectAssocTypeSynInstances' inst@(Declaration_Instance _ _ n1 its _) (Declaration_TypeFamInstance _ _ n ts t:is) 
  = IAssoc n ts t its n1 : collectAssocTypeSynInstances' inst is
collectAssocTypeSynInstances' inst (_:is) = collectAssocTypeSynInstances' inst is
collectAssocTypeSynInstances' _    []     = []
}

-- Type family decls and instances collection.
ATTR Body Declarations Declaration [ | | collectTypeFamilyDecls USE { ++ } { [] } : {TFDeclInfos} ]
ATTR Body MaybeDeclarations Declarations Declaration [ | | collectTypeFamilyInstances USE { ++ } { [] } : {TFInstanceInfos}]
-- Id that is given to Type Instance declarations in a closed type family
ATTR Declarations Declaration [ instId : {Int} | | ]

SEM MaybeDeclarations
    | Just lhs.collectTypeFamilyInstances = @declarations.collectTypeFamilyInstances
           declarations.instId = 0

SEM Declarations
    | Cons hd.instId = @lhs.instId
           tl.instId = @lhs.instId + 1

SEM Declaration
    | Class lhs . collectTypeFamilyDecls = collectAssocTypeSynDecls @self @where.self
    | TypeFam lhs . collectTypeFamilyDecls = collectTypeFamDecls @self : []
              lhs . collectTypeFamilyInstances = @where.collectTypeFamilyInstances
    | TypeFamInstance lhs . collectTypeFamilyInstances = collectTypeFamInstance @self @lhs.instId : []
    | Instance lhs . collectTypeFamilyInstances = collectAssocTypeSynInstances @self @where.self

-------------------------------------------
-- Collecting Type Signatures

ATTR Declaration Declarations [ | typeSignatures:{[(Name,TpScheme)]} | ]
ATTR Body MaybeDeclarations   [ | | typeSignatures:{[(Name,TpScheme)]} ]
ATTR Declaration Declarations MaybeDeclarations [ | | functionDefaults USE {(++)} {[]} : {[Name]}]

SEM Body
  | Hole lhs . typeSignatures = []
  | Body    declarations . typeSignatures = []
SEM Expression        | Let     declarations . typeSignatures = []
SEM Statement         | Let     declarations . typeSignatures = []
SEM Qualifier         | Let     declarations . typeSignatures = []
SEM MaybeDeclarations | Just    declarations . typeSignatures = []
                      | Nothing lhs          . typeSignatures = []


SEM Declaration
  | TypeSignature
      lhs . typeSignatures = [ (name, @typeScheme) | name <- @names.self ] ++ @lhs.typeSignatures
      loc . (typeScheme, intMap) = makeTpSchemeFromType' @type.self
  | Class
      --lhs . typeSignatures = [] --@where.typeSignatures
  | Instance
      lhs . typeSignatures = @where.typeSignatures -- And we apply the same trick again
  | FunctionBindings
      lhs . functionDefaults = [@bindings.name]

-------
-- Building a Class Environment

ATTR Body [ importedClassEnv : {ClassEnvironment}| | ]

SEM Module
  | Module body . importedClassEnv = classEnvironment $ combineImportEnvironmentList @lhs.importEnvironments

ATTR Body Declaration Declarations [
    |
    |
        classEnv USE {`M.union`} {M.empty} : {ClassEnvironment}
        instanceEnv USE {`M.union`} {M.empty} : {InstanceEnvironment}
        classInstances USE {(++)} {[]} : {[(String, Tp, [(String, Tp)])]}
]

SEM Declaration
    | Class
        lhs . classEnv = M.singleton (getClassName @simpletype.self) ((map fst $ getSuperClasses @context.self), [])
    | Instance
       lhs . classInstances = let
                                superClasses :: [(String, Tp)]
                                superClasses = map (\(c, tpss)-> (c, unqualify $ unquantify $ head tpss)) $ getSuperClasses @context.self
                              in [(getNameName $ @name.self, makeTpFromType' $ head @types.self, superClasses)] 

       lhs . instanceEnv = M.singleton (@name.self, makeTpFromType' $ head @types.self) (namesInType (head @types.self), map (\(n, tp) -> (n, show $ head tp)) $ getSuperClasses @context.self)
    | Data  lhs . instanceEnv = M.fromList 
                                    [
                                        let className = dn
                                            dataName = @simpletype.name
                                            tvs = @simpletype.typevariables
                                            tVars = zip tvs (map TVar [0..])
                                            key = (dn, foldl TApp (TCon $ show dataName) $ map snd tVars)
                                            value = (tvs, [(show dn, tv) | tv <- map show tvs])
                                        in (key, value) | dn <- @derivings.self
                                    ]
            lhs . classInstances =  [
                                        let 
                                            tvs = @simpletype.typevariables
                                            tVars = zip tvs (map TVar [0..])
                                            typeClass = foldl TApp (TCon $ show @simpletype.name) $ map snd tVars
                                        in (show dn, typeClass, map (\x -> (show dn, snd x)) tVars)
                                        | dn <- @derivings.self
                                    ]
        
{

getTypeOfInstanceFunction :: Name -> Name -> ClassMemberEnvironment -> TpScheme
getTypeOfInstanceFunction instanceName name env = case M.lookup instanceName env of
        Just c ->   let (_, functions) = c
                        (_, tp, _, _) = fromMaybe (error "Unknown function in instance") (lookupFunc name functions)
                    in tp
        Nothing -> error "Unknown class in instance declaration"
    where
        lookupFunc :: Name -> [(Name, a, b, c)] -> Maybe (Name, a, b, c)
        lookupFunc _ [] = Nothing
        lookupFunc n (f@(nf, _, _, _):fs)  | n == nf   = Just f
                                        | otherwise = lookupFunc n fs

getClassName :: SimpleType -> String
getClassName (SimpleType_SimpleType _ n _) = getNameName n

getSuperClasses ::  ContextItems -> [(String, [TpScheme])]
getSuperClasses = map (\(ContextItem_ContextItem _ n vs) -> (getNameName n, (map makeTpSchemeFromType vs)))

getInstanceFunctionNames :: MaybeDeclarations -> [Name]
getInstanceFunctionNames (MaybeDeclarations_Nothing) = []
getInstanceFunctionNames (MaybeDeclarations_Just ds) = fmap (\d -> getDeclarationName d) ds

getDeclarationName :: Declaration -> Name
getDeclarationName (Declaration_FunctionBindings _ []) = error "No function bindings found" 
getDeclarationName (Declaration_FunctionBindings _ [fb]) = getFunctionBindingName fb
getDeclarationName (Declaration_FunctionBindings _ fb) =
        let names = map getFunctionBindingName fb 
            valid = all (==(head names)) names
        in if valid then head names else error "Inconsistent names in function bindings"

getDeclarationName _ = error $ "Unknown declaration in instance"

getFunctionBindingName :: FunctionBinding -> Name
getFunctionBindingName (FunctionBinding_FunctionBinding _ lhs _)= getLhsName lhs

getLhsName :: LeftHandSide -> Name
getLhsName (LeftHandSide_Function _ name _) = name
getLhsName (LeftHandSide_Infix _ _ name _) = name
}

ATTR Body Declaration Declarations [ | | instances USE {++} {[]} : {[(Range, Instance)]} ]

SEM Declaration
  | Instance
     lhs . instances = [createInstance @range.self @name.self (head @types.self) @context.self]
  | Data
    lhs. instances = [ (@range.self, makeInstance (show cl) (length @simpletype.typevariables) (show @simpletype.name) True)
                                | cl <- @derivings.self
                                ]
    

{

createInstance :: Range -> Name -> Type -> ContextItems -> (Range, Instance)
createInstance r n ty ctx = (r, (makePredicate n ty , map (\(ContextItem_ContextItem _ n2 tys) -> makePredicate n2 (head tys)) ctx))
   where nameMap = makeNameMap (namesInTypes $ ty : (map (\(ContextItem_ContextItem _ _ tys) -> head tys) ctx))
         makePredicate :: Name -> Type -> Predicate
         makePredicate nm typ = Predicate (getNameName nm) (makeTpFromType nameMap typ)

}


