
ATTR Module [
    | | toplevelTypes USE {M.union} {M.empty}  : TypeEnvironment
]

ATTR Module Body Declaration Declarations Expression Expressions
     GuardedExpression GuardedExpressions
     MaybeExpression RecordExpressionBinding
     RightHandSide Alternative Alternatives FunctionBinding
     FunctionBindings RecordExpressionBindings
     AnnotatedType Types Constructor AnnotatedTypes 
     ContextItem FieldDeclaration Constructors ContextItems 
     FieldDeclarations Type Literal LeftHandSide RightHandSide
     Pattern Patterns
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType ConstraintInfo)}
                importEnvironment : ImportEnvironment
                axioms : {[Axiom ConstraintInfo]}
                typeSignatureConstraints : {[Constraint ConstraintInfo]}
                typeVariableReplace : {[(String, MonoType)]}
                className : {Maybe Name}

            |   betaUnique : Integer
            |   assumptions USE {M.unionWith (++)} {M.empty} : {M.Map Name [(Name, TyVar)]}
                environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                constraints USE {(++)} {[]} : {[Constraint ConstraintInfo]}
                givenConstraints USE {(++)} {[]} : {[Constraint  ConstraintInfo]}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                touchables USE {(++)} {[]} : {[TyVar]}
                
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType ConstraintInfo)}
                typeErrors USE {(++)} {[]} : TypeErrors

                tlEnvironment USE {M.union} {M.empty} : {M.Map Name TyVar}
                resolvedContraints USE {(++)} {[]} : {[Constraint ConstraintInfo]}
                gadtConstraints USE {(++)} {[]} : GADTConstraints
                gadtUsed USE {(||)} {False} : Bool
        ]

ATTR MaybeDeclarations Qualifier Qualifiers Statement Statements
        [ 
                typeSignatures : {M.Map Name (TyVar, PolyType ConstraintInfo)}
                importEnvironment : ImportEnvironment
                axioms : {[Axiom ConstraintInfo]}
                typeSignatureConstraints : {[Constraint ConstraintInfo]}
                typeVariableReplace : {[(String, MonoType)]}
                className : {Maybe Name}
            |   betaUnique : Integer
            |   environment USE {M.union} {M.empty} : {M.Map Name TyVar}
                bindingGroups USE {(++)} {[]} : {[BindingGroup]}
                typeSignaturesCollect USE {M.union} {M.empty} : {M.Map Name (TyVar, PolyType ConstraintInfo)}
                typeErrors USE {(++)} {[]} : TypeErrors
                resolvedContraints USE {(++)} {[]} : {[Constraint ConstraintInfo]}
        ]

ATTR Body [  | |               substitutionCollect : {[(TyVar, MonoType)]}]

{

unifyVar :: TyVar -> TyVar -> ConstraintInfo -> Constraint ConstraintInfo
unifyVar v1 v2 ci = Constraint_Unify (var v1) (var v2) (Just ci)

substitutePoly :: TyVar -> [(TyVar, MonoType)] -> MonoType
substitutePoly v env = case lookup v env of
    Nothing -> error $ "Cannot provide substitution for " ++ show v
    Just m -> m

type SolveResult = ([TypeError], [Warning], [(TyVar, MonoType)], Constraints)

constructErrors :: SR.SolveResult TyVar MonoType (Constraint ConstraintInfo) ConstraintInfo -> SolveResult
constructErrors sr = (const [] $ mapMaybe (errorMessage . (\(ci, _, _) -> ci)) (SR.errors sr), [], SR.substitution sr, [])

getTypeErrors :: SolveResult -> [TypeError]
getTypeErrors (te, _, _, _) = te

getWarnings :: SolveResult -> [Warning]
getWarnings (_, wa, _, _) = wa

getSubstitution :: SolveResult -> [(TyVar, MonoType)]
getSubstitution (_, _, subs, _) = subs

getResidualConstraints :: SolveResult -> [Constraint ConstraintInfo]
getResidualConstraints (_, _, _, cs) = cs

lookupType :: M.Map Name (TyVar, PolyType ConstraintInfo) -> Name -> TyVar -> TpScheme
lookupType env name _ = 
    case M.lookup name env of
        Nothing -> internalError "TypeInferenceRules" "lookupType" "Top level type not found"
        Just (_, p) -> polyTypeToTypeScheme p

eqAssEnv :: Assumptions -> Environment -> (Name -> ConstraintInfo) -> ([Constraint ConstraintInfo], Assumptions)
eqAssEnv ass env cinfo = 
    (
        concat $ M.elems (M.intersectionWith (\a' e -> [unifyVar a e (cinfo n) | (n, a) <- a']) ass env),
        ass M.\\ env
    )
}

SEM Module
    | Module
        lhs . dictionaryEnvironment = emptyDictionaryEnvironment
        lhs . toplevelTypes = if null @typeErrors then M.mapWithKey (lookupType @body.typeSignaturesCollect) @body.tlEnvironment else M.empty
        loc . typeErrors = concatMap (makeTypeError @tyvars) (getResidualConstraints @solveResults \\ @body.resolvedContraints) ++ getTypeErrors @solveResults ++ @body.typeErrors
        lhs . warnings = getWarnings @solveResults
        loc . axioms = typeSynonymsToAxioms (typeSynonyms @lhs.importEnvironment) 
                        ++ classEnvironmentToAxioms @tyFams (classEnvironment @lhs.importEnvironment)
                        ++ trace (show $ typeFamiliesToAxioms @tyFams @lhs.importEnvironment) typeFamiliesToAxioms @tyFams @lhs.importEnvironment
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
        body . axioms = @axioms
        body . betaUnique = 1
        loc . constrs = @body.constraints
        loc . tyvars = @body.touchables
        loc . solveResults = 
                let 
                    sibblings = map (map (second (tpSchemeToPolyType @tyFams))) $ getSiblings @lhs.importEnvironment
                in constructErrors $ contFreshM (solveOU sibblings @axioms (map ((\(v, m) -> Constraint_Unify (var v) m Nothing)) @body.substitutionCollect) (@constrs) @tyvars) @body.betaUnique 
        body . typeSignatures = M.map (\tps -> (integer2Name (-1), tpSchemeToPolyType @tyFams tps)) $ typeEnvironment @lhs.importEnvironment
        body . className = Nothing
        body . typeSignatureConstraints = []

SEM Body
    | Body
        lhs . constraints = @loc.constraints
        declarations . betaUnique = @lhs.betaUnique
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            lhs . substitutionCollect,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let inputBDG = id $! (@lhs.importEnvironment, True, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables, Nothing, @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

ATTR FunctionBinding FunctionBindings [ betasLeft : {[TyVar]} betaRight : TyVar | caseArmIndex : Int | name : Name numberOfPatterns : Integer  ]


SEM Declaration
    | FunctionBindings
        lhs . betaUnique        = @bindings.betaUnique
        lhs . bindingGroups     = [@bindingGroup]
        loc . bindingGroup      = (@environment, @assumptions, @constraints, @lhs.typeSignatureConstraints ++ @instanceCons ++ @bindings.givenConstraints, @bindings.gadtConstraints)
        lhs . tlEnvironment     = @environment
        loc . environment       = if isJust @lhs.className then M.empty else M.singleton @bindings.name @beta 
        loc . assumptions       = @bindings.assumptions 
        lhs . touchables        = @beta : @br : @bls ++ @bindings.touchables
        loc . constraints       = @instanceCons ++ @parameterCons ++ @bindings.constraints 
        loc . bls               = take (fromInteger @bindings.numberOfPatterns) (map integer2Name [(@lhs.betaUnique + 2)..])
        loc . br                = integer2Name $ @lhs.betaUnique + 1
        loc . beta              = UL.makeName (show @bindings.name) @lhs.betaUnique
        loc . parameterCons     = [Constraint_Unify (var @beta) (foldr ((:-->:) . var) (var @br) @bls) (Just @cinfo)]
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
        loc . (instanceType, bu) = case @lhs.className of
                                        Nothing -> (Nothing, (@lhs.betaUnique + 2 + @bindings.numberOfPatterns))
                                        Just cn -> let 
                                                (classTypeVariables, classFunctions) = fromMaybe (internalError "TypeInferenceRules" "n/a" "class not found") $
                                                    M.lookup cn (classMemberEnvironment @lhs.importEnvironment)
                                                (_, functionTpScheme, _, _) = fromMaybe (internalError "TypeInferenceRules" "n/a" "class function not found")
                                                    (find (\(n, _, _, _) -> n == @bindings.name) classFunctions) 
                                                (polyType, mapping) = tpSchemeToPolyType' @tyFams (map show classTypeVariables) functionTpScheme
                                            
                                                (fMapping, (freshend, bu)) = freshenWithMapping [] (@lhs.betaUnique + 2 + @bindings.numberOfPatterns) polyType
                                                replacedFreshened = UL.substs (combineSubsitutions @lhs.typeVariableReplace mapping fMapping) freshend
                                            in (Just replacedFreshened, bu)
        loc . instanceCons      = maybe [] (\it -> [Constraint_Inst (var @beta) (foldr addConstraint it @lhs.typeSignatureConstraints) (Just @cinfo)])  @instanceType    
        loc . err               = internalError "TypeInferenceRules.ag" "FunctionBindings" ("No substitution found for " ++ show @bindings.name)
        bindings . betasLeft    = @bls 
        bindings . betaRight    = @br 
        bindings . betaUnique   = @bu
        bindings . className    = Nothing
    | PatternBinding
        lhs . tlEnvironment     = @environment
        lhs . bindingGroups     = [@bindingGroup]
        loc . bindingGroup      = (@environment, @assumptions, @constraints, [], @righthandside.gadtConstraints)
        lhs . touchables        = @betaRight : @pattern.touchables ++ @righthandside.touchables
        loc . constraints       = [unifyVar @pattern.beta @betaRight @cinfo, unifyVar @betaRight @righthandside.beta @cinfo] ++ @pattern.constraints ++ @righthandside.constraints
        loc . environment       = @pattern.environment
        loc . assumptions       = @righthandside.assumptions
        pattern . betaUnique    = @lhs.betaUnique + 1 
        pattern . className     = Nothing
        righthandside . className = Nothing
        loc . betaRight         = integer2Name @lhs.betaUnique

    | TypeSignature
        lhs . touchables        = @beta : map fst (M.elems @ts)
        loc . beta              = integer2Name @lhs.betaUnique
        lhs . betaUnique        = @bu
        lhs . typeSignaturesCollect = @ts
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
        loc . (ts, bu)          = foldr (\n (m, b) -> let 
                                                (t, b', mapping) = typeToPolytype @tyFams b @type.self
                                                t' = t
                                                m' = M.insert n (integer2Name b', expandClassPredicates (classEnvironment @lhs.importEnvironment) t') m
                                            in (m', b' + 2)) (M.empty, @lhs.betaUnique + 1) $ @names.self
    | Class
        where       . betaUnique    = @lhs.betaUnique + toInteger (length @simpletype.typevariables)
        loc         . classBetas    = zip (map show @simpletype.typevariables) (map integer2Name [@lhs.betaUnique..])
        lhs         . touchables    = map snd @classBetas ++ @where.touchables
        lhs         . typeSignaturesCollect = M.empty -- @where.typeSignaturesCollect
        where . typeVariableReplace = map (second var) @classBetas
        where . className           = Just  @simpletype.name
        where . typeSignatureConstraints = [Constraint_Class (show @simpletype.name) (map (var.snd) @classBetas) Nothing] ++ map (\(ContextItem_ContextItem _ cn ts) -> Constraint_Class (show cn) (map (var . snd) @classBetas) Nothing) @context.self
    | Instance
        lhs . touchables = fvToList @tp ++ take (length @typeVariables) [x | i <- [@lhs.betaUnique..], let x = integer2Name i] ++ @where.touchables
        loc . instanceBetas = (@classBeta, @tp) : [] -- zip (map snd @typeVariables) (map (var . integer2Name) [@lhs.betaUnique..])
        loc . instanceType  = makeTpSchemeFromType $ head @types.self
        loc . typeVariables = getQuantorMap @instanceType
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
        loc . classBeta     = case (M.lookup @name.self (classMemberEnvironment @lhs.importEnvironment)) of
                                Nothing -> internalError "TypeInferenceRules" "n/a" "Class not found"
                                Just (classBeta, _) -> show $ head classBeta
        loc . ((tp, mapping), bu) = freshen (@lhs.betaUnique + toInteger (length @instanceBetas + 1)) $ (\(_, mapping, x) -> (x, mapping)) $ typeToMonoType @tyFams (head @types.self)
        where . betaUnique = @bu
        where . className = Just @name.self
        where . typeSignatureConstraints = 
                    concatMap (
                        \(ContextItem_ContextItem _ cn ts) -> expandClassPredicate (classEnvironment @lhs.importEnvironment) $ Constraint_Class (show cn)
                            [maybe (error "Unknown type variable") var $ lookup (show (makeTpSchemeFromType $ head ts)) @mapping] Nothing
                    ) @context.self
        where . typeVariableReplace = reverse $ @instanceBetas
    | TypeFam -- all MaybeDecl stuff is empty as only TypeFamInstances can occur that don't matter here (axioms will be created for them)
        where . className = Just @simpletype.name
        where . touchables = []
        where . gadtConstraints = []
        where . constraints = []
        where . assumptions = M.empty

{

combineSubsitutions :: [(String, MonoType)] -> [(String, TyVar)] -> [(Integer, Integer)] -> [(TyVar, MonoType)]
combineSubsitutions [] _ _ = []
combineSubsitutions ((s,tv):rst) mapping fmapping = (combineSubsitutions rst mapping fmapping) ++ 
    fromMaybe [] (
        do
            parsedTV <- lookup s mapping
            let parsedInt = UL.name2Integer parsedTV
            replacedTV <- lookup parsedInt fmapping
            return $ [(integer2Name replacedTV, tv)] 
    )


}

ATTR SimpleType [ | | name:Name typevariables:Names ]

SEM SimpleType
  | SimpleType  lhs . name          = @name.self
                    . typevariables = @typevariables.self

ATTR Pattern    [ | | beta : TyVar ]
ATTR Patterns   [ | | betas : {[TyVar]} numberOfPatterns:Integer ]


SEM Patterns
  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . numberOfPatterns = 1 + @tl.numberOfPatterns
  | Nil
      lhs . betas            = []
          . numberOfPatterns = 0
SEM Pattern
    | Variable
        lhs . touchables    = [@beta]
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . environment   = M.singleton @name.self @beta
        loc . beta          = UL.makeName (show @name.self) @lhs.betaUnique
    | Literal
        lhs . touchables    = [@beta]
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType (Just @cinfo)]
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
    | Tuple
        patterns    . betaUnique        = @lhs.betaUnique + 1
        lhs         . constraints       = @constraint : @patterns.constraints
        lhs         . touchables        = @beta : @patterns.touchables
        loc         . beta              = integer2Name @lhs.betaUnique
                    . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @patterns.betas)) (Just @cinfo)
    | Wildcard
        lhs         . touchables        = [@beta]
        lhs         . betaUnique        = @lhs.betaUnique + 1
        loc         . beta              = integer2Name @lhs.betaUnique
    | List 
        lhs         . touchables        = @beta : @elemBeta : @patterns.touchables
        lhs         . constraints       = @lstConstraints ++ @patterns.constraints
        patterns    . betaUnique        = @lhs.betaUnique + 2
        loc         . beta              = integer2Name @lhs.betaUnique
        loc         . elemBeta          = integer2Name (@lhs.betaUnique + 1)
        loc         . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) (Just @cinfoResult) : map (\v -> unifyVar @elemBeta v (@cinfoElem $ fromInteger $ UL.name2Integer v)) @patterns.betas
    | Constructor
        patterns    . betaUnique        = @bu3
        lhs . gadtUsed                  = @ct == ConstructorGADT || @patterns.gadtUsed
        lhs . touchables                = @beta : @betaCon : (
                                             if @ct == ConstructorRegular then 
                                                []
                                             else
                                                [] -- UL.fv @rt 
                                            ) ++ fvToList (getRHSPT @tp) ++ @patterns.touchables
        lhs . constraints               =   if @ct == ConstructorRegular then 
                                                @conApply : @conConstraints ++ @patterns.constraints
                                            else
                                                [] -- [Constraint_Unify (var @beta) @rt (Just @cinfoConstructor)]
        lhs . gadtCondition             = [modCi (addProperty FolkloreConstraint) @conApply, Constraint_Inst (var @betaCon) (bindVariables (map (\v -> ("", v)) $ fvToList (getRHSPT @tpW)) @tpW) (Just $ addProperty (TypeSignatureLocation @origTpschemeRange) @cinfoConstructor)]
        loc . (tpW, bu3)                = freshen @bu2 @tp
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (foldr (:-->:) (var @beta) (map var @patterns.betas) ) 
                                                (Just $ addProperties [FolkloreConstraint, GADTPatternApplication, TypeSignatureLocation @origTpschemeRange] @cinfoApply)
        loc . origTpschemeRange         =   let
                                                nameList = M.filterWithKey (\n _ -> n == @name.self) (valueConstructors @lhs.importEnvironment)
                                            in  if null nameList then
                                                    noRange
                                                else
                                                    getNameRange $ head (M.keys nameList)
        loc . conConstraints            = [Constraint_Inst (var @betaCon) (bindVariables (map (\v -> ("", v)) $ fvToList (@tp)) @tp) (Just $ addProperty (TypeSignatureLocation @origTpschemeRange) @cinfoConstructor)]
        loc . gadtVariables             =   if @ct == ConstructorRegular then 
                                                []
                                            else
                                                @betaCon : @patterns.touchables ++ fvToList (getRHSPT @tp)
        loc . gadtAssumeConstraints     =   if @ct == ConstructorRegular then 
                                                []
                                            else
                                                @conApply : @conConstraints ++ @resConstraints ++ @patterns.constraints
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
        loc . ((tp, bu), ct)            = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                            Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                            Just (ctp, ct) -> (freshen (@lhs.betaUnique + 2) $ unbindPolyType $ tpSchemeToPolyType @tyFams ctp, ct)
        loc . ((rt, conrt, resConstraints), bu2) = freshen (@bu + 1) $ getResultType @tp

    | InfixConstructor
        leftPattern . betaUnique        = @bu
        lhs . touchables                = @beta : @betaCon : @leftPattern.touchables ++ @rightPattern.touchables ++ getTypeVariablesFromPolyType' @tp
        lhs . constraints               = @conApply : @conConstraints ++ @leftPattern.constraints ++ @rightPattern.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . betaCon                   = integer2Name (@lhs.betaUnique + 1)
        loc . conApply                  = Constraint_Unify (var @betaCon) (var @leftPattern.beta :-->: (var @rightPattern.beta :-->: var @beta)) (Just @cinfoApply)
        loc . (tp, bu)                  = case M.lookup @constructorOperator.self (valueConstructors @lhs.importEnvironment) of
                                            Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                            Just (ctp, _) -> freshen (@lhs.betaUnique + 2) $ tpSchemeToPolyType @tyFams ctp
        loc . conConstraints            = [Constraint_Inst (var @betaCon) @tp (Just @cinfoConstructor)]
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
    | As
        pattern . betaUnique            = @lhs.betaUnique + 1
        lhs . touchables                = @beta : @pattern.touchables
        lhs . constraints               = unifyVar @beta @pattern.beta @cinfo : @pattern.constraints 
        lhs . environment               = M.insert @name.self @beta @pattern.environment
        loc . beta                      = integer2Name @lhs.betaUnique
    | Negate 
        literal . betaUnique            = @bu
        lhs . touchables                = @beta : @literal.touchables
        lhs . constraints               = [Constraint_Inst (@literal.literalType :-->: var @beta) @tp (Just @cinfo)] ++ @literal.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
        loc . (tp, bu)                  =   let standard = PolyType_Mono [Constraint_Class "Num" [var $ integer2Name 0] (Just @cinfo)] ((var $ integer2Name 0) :-->: (var $ integer2Name 0))
                                            in freshen (@lhs.betaUnique + 1) $ M.findWithDefault standard (nameFromString "negate") (tpSchemeToPolyType @tyFams <$> typeEnvironment @lhs.importEnvironment)
    | NegateFloat
        lhs . betaUnique  = @lhs.betaUnique + 1
        lhs . touchables  = @beta : @literal.touchables
        loc . constraints = [ Constraint_Unify (MonoType_Con "Float") (var @beta) (Just @cinfo)] ++ @literal.constraints
            . beta        = integer2Name @lhs.betaUnique


{

getRHSPT :: PolyType ConstraintInfo -> MonoType
getRHSPT (PolyType_Mono _ m) = getRHS m

getRHS :: MonoType -> MonoType
getRHS (f :-->: a) = getRHS a
getRHS x = x

getResultType :: PolyType ConstraintInfo -> (MonoType, MonoType, [Constraint ConstraintInfo])
getResultType x = getResultTypeHelper 0 x

getResultTypeHelper :: Integer -> PolyType ConstraintInfo -> (MonoType, MonoType, [Constraint  ConstraintInfo])
getResultTypeHelper i (PolyType_Mono cs m) = (\(mr, m, c, _) -> (mr, m, c ++ cs)) (getResultTypeM i m)
getResultTypeHelper i (PolyType_Bind _ b) = contFreshM (UL.unbind b >>= (\(t, x) -> return $ getResultTypeHelper (UL.name2Integer t + 1) x)) i

getResultTypeM :: Integer -> MonoType -> (MonoType, MonoType, [Constraint  ConstraintInfo], Integer)
getResultTypeM i (f :-->: a) = let 
                                    (_, m1, cs1, i1) = getResultTypeM i f
                                    (r, m2, cs2, i2) = getResultTypeM i1 a
                                in (r, m1 :-->: m2, cs1 ++ cs2, i2) 
getResultTypeM i (MonoType_App y x) =  let 
                                    (m1, cs1, i1) = getResultTypeM' i y 
                                    (m2, cs2, i2) = getResultTypeM' i1 x
                                in (MonoType_App m1 m2, MonoType_App m1 m2, cs1 ++ cs2, i2) 
getResultTypeM i (MonoType_Con s)   = (MonoType_Con s, MonoType_Con s, [], i) --let v = var $ integer2Name i in (v, v, [Constraint_Unify v (MonoType_Con s) $ Just emptyConstraintInfo], i + 1)
getResultTypeM i f@(MonoType_Fam _ _) = (f, f, [], i)
getResultTypeM i (MonoType_Var s v)   = (internalError "TypeInferenceRules" "getResultTypeM" "Return type of a GADT can never be a type variable", MonoType_Var s v, [], i)

getResultTypeM' :: Integer -> MonoType -> (MonoType, [Constraint ConstraintInfo], Integer)
getResultTypeM' i (MonoType_Var s v) = (MonoType_Var s v, [], i)
getResultTypeM' i (MonoType_Con "->") = (MonoType_Con "->", [], i)
getResultTypeM' i (MonoType_Con c) = (MonoType_Con c, [], i) -- (var (integer2Name i), [Constraint_Unify (var $ integer2Name i) (MonoType_Con c) $ Just emptyConstraintInfo], i + 1) 
getResultTypeM' i (MonoType_App x y) = let 
                                    (m1, cs1, i1) = getResultTypeM' i x
                                    (m2, cs2, i2) = getResultTypeM' i1 y
                                in (MonoType_App m1 m2, cs1 ++ cs2, i2) 
}
        
SEM FunctionBinding 
    | FunctionBinding
        lhs . touchables        = @lefthandside.touchables ++ @righthandside.touchables
        lhs . assumptions       = if null @lefthandside.gadtVariables then @assumptions else M.empty
        lhs . constraints       =   if null @lefthandside.gadtVariables then 
                                       @lefthandside.constraints ++ @righthandside.constraints  ++ @assConstraints ++ @locConstraints
                                    else
                                        @lefthandside.constraints ++ @locConstraints
        lhs . gadtConstraints   =   if null @lefthandside.gadtVariables then 
                                        @subGADTConstraints 
                                    else
                                        [GADTConstraint @lhs.caseArmIndex
                                            (@righthandside.touchables ++ @lefthandside.gadtVariables) 
                                            @lefthandside.gadtAssumeConstraints
                                            (@lefthandside.gadtCondition ++ @righthandside.constraints ++ @assConstraints)
                                            @assumptions
                                            @subGADTConstraints
                                            emptyConstraintInfo
                                        ] ++ @righthandside.gadtConstraints
                                    
        lhs . name              = @lefthandside.name
        lhs . numberOfPatterns  = @lefthandside.numberOfPatterns
        loc . locConstraints    = zipWith3 (\bt bb nr -> Constraint_Unify (var bb) (var bt) (Just $ @cinfoLeft nr)) @lhs.betasLeft @lefthandside.betas [0..]
        loc . (assConstraints', assumptions) = eqAssEnv @righthandside.assumptions @lefthandside.environment @cinfoBind
        loc . assConstraints     = @assConstraints' ++ [Constraint_Unify (var @lhs.betaRight) (var @righthandside.beta) $ Just @cinfoRight ]
        loc . subGADTConstraints = map (resolveEnv @lefthandside.environment) @righthandside.gadtConstraints

{

resolveEnv :: Environment -> GADTConstraint -> GADTConstraint
resolveEnv env c = c{
        gadtImplication = gadtImplication c ++ (concat $ M.elems $ M.intersectionWith (\a e -> [Constraint_Inst (var a') (var e) Nothing | (_, a') <- a]) (gadtAssumptions c) env),
        gadtAssumptions = gadtAssumptions c M.\\ env,
        gadtSubGADTConstraints = map (resolveEnv env) (gadtSubGADTConstraints c)
    }

}

ATTR FunctionBinding LeftHandSide Pattern Patterns 
    [ 
    | 
    |
        gadtVariables USE {(++)} {[]} : {[TyVar]}
        gadtCondition USE {(++)} {[]} : {[Constraint ConstraintInfo]}
        gadtAssumeConstraints USE {(++)} {[]} : {[Constraint ConstraintInfo]}
    ]        

SEM FunctionBindings

  | Cons
        lhs . numberOfPatterns  = @hd.numberOfPatterns
            . name              = @hd.name
        hd  . caseArmIndex      = @tl.caseArmIndex
        lhs . caseArmIndex      = @hd.caseArmIndex + 1
  | Nil
        lhs . numberOfPatterns  = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
            . name              = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"
            . caseArmIndex      = 0


ATTR LeftHandSide   [ | | name : {Name} betas : {[TyVar]} numberOfPatterns:Integer ]

SEM LeftHandSide
    | Function
        lhs . betas             = @patterns.betas
        lhs . numberOfPatterns  = @patterns.numberOfPatterns
        lhs . name              = @name.self
    | Infix
        lhs . betas             = [@leftPattern.beta, @rightPattern.beta]
        lhs . numberOfPatterns  = 2
        lhs . name              = @operator.self
    | Parenthesized
        lhs . betas = @lefthandside.betas ++ @patterns.betas
        lhs . numberOfPatterns = @lefthandside.numberOfPatterns + @patterns.numberOfPatterns

ATTR RightHandSide  [ betaRight : TyVar | | beta : TyVar]

SEM RightHandSide
    | Expression
        lhs     . gadtConstraints = @where.gadtConstraints
        lhs     . assumptions = @where.assumptions
                . constraints = @where.constraints
        where   . assumptions = @expression.assumptions
                . constraints = @expression.constraints
    | Guarded
        lhs                 . beta           = @lhs.betaRight
        lhs                 . assumptions    = @where.assumptions
                            . constraints    = @where.constraints
        where               . assumptions    = @guardedexpressions.assumptions
                            . constraints    = @guardedexpressions.constraints

ATTR GuardedExpressions GuardedExpression [ betaRight:TyVar | | beta : TyVar]

SEM GuardedExpression

  | GuardedExpression
      lhs . constraints = 
                [
                    Constraint_Unify (var @guard.beta) (MonoType_Con "Bool") (Just @cinfoGuard), 
                    (unifyVar @expression.beta @lhs.betaRight @cinfoExpr)
                ] ++ @guard.constraints ++ @expression.constraints

ATTR MaybeDeclarations [ | touchables : Touchables assumptions:Assumptions constraints:Constraints gadtConstraints : GADTConstraints| ]

SEM MaybeDeclarations
    | Just
        lhs . touchables        = if isJust @lhs.className then @declarations.touchables ++ @lhs.touchables else @touchables1
        lhs . constraints       = if isJust @lhs.className then @declarations.constraints else @constraints1
        lhs . bindingGroups     = if isJust @lhs.className then @declarations.bindingGroups else []
        lhs . assumptions       = if isJust @lhs.className then @declarations.assumptions else @assumptions1
        lhs . typeSignatureCollect = if isJust @lhs.className then @declarations.typeSignaturesCollect else @typeSignatureCollect1
        lhs . typeErrors        = if isJust @lhs.className then @declarations.typeErrors else @typeErrors1
        lhs . betaUnique        = if isJust @lhs.className then @declarations.betaUnique else @bu1
        lhs . resolvedContraints = if isJust @lhs.className then @declarations.resolvedContraints else @resolvedContraints1
        (
            loc . touchables1,
            loc . assumptions1,
            loc . typeSignaturesCollect1,
            loc . constraints1,
            loc . bu1,
            _,
            loc . typeErrors1,
            loc . resolvedContraints1
        ) = @bgResult
        loc . bgResult = 
                if isJust @lhs.className then 
                    let err x = error $ "Should not need where" ++ show x
                    in (err 1, err 2, err 3, err 4, err 5, err 6, err 7, err 8)
                else let 
                    inputBDG = (@lhs.importEnvironment, False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.gadtConstraints), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
                in bindingGroupAnalysis inputBDG @declarations.bindingGroups



ATTR Expression MaybeExpression [ | | beta : TyVar]
ATTR Expressions [ | | betas : {[TyVar]} nrOfExpressions : Integer]

SEM Expressions
    | Cons
        lhs . betas = @hd.beta : @tl.betas
        lhs . nrOfExpressions = @tl.nrOfExpressions + 1
    | Nil 
        lhs . betas = []
        lhs . nrOfExpressions = 0


SEM Expression
    | Literal
        lhs . betaUnique    = @lhs.betaUnique + 1
        loc . beta          = integer2Name @lhs.betaUnique
        lhs . constraints   = [Constraint_Unify (var @beta) @literal.literalType (Just @cinfo)]
        lhs . touchables    = [@beta]
    | Variable
        lhs . touchables    = [@beta]
        loc . beta          = UL.makeName (show @name.self) @lhs.betaUnique
        lhs . betaUnique    = @lhs.betaUnique + 1
        lhs . assumptions   = M.singleton @name.self [(@name.self, @beta)]
    | NormalApplication
        loc . beta              = integer2Name @lhs.betaUnique
        function . betaUnique   = @lhs.betaUnique + 1
        lhs . touchables        = @beta : @function.touchables ++ @arguments.touchables
        lhs . constraints       = [@constraint] ++ @function.constraints ++ @arguments.constraints
        loc . constraint        = Constraint_Unify (var @function.beta) (foldr (:-->:) (var @beta) (map var @arguments.betas)) (Just @cinfo)
    | If
        lhs . constraints       = @constraints ++ concat [@guardExpression.constraints, @thenExpression.constraints, @elseExpression.constraints]
        lhs . touchables        = @beta : concat [ @guardExpression.touchables, @thenExpression.touchables, @elseExpression.touchables ]
        guardExpression.betaUnique = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . constraints       =   [
                                        Constraint_Unify (var @guardExpression.beta) (MonoType_Con "Bool") (Just @cinfoGuard),
                                        unifyVar @beta @thenExpression.beta @cinfoThen,
                                        unifyVar @beta @elseExpression.beta @cinfoElse
                                    ]
    | Lambda
        lhs . touchables        = @beta : @expression.touchables ++ @patterns.touchables
        lhs . constraints       = @fConstraint : @envConstraints ++ @expression.constraints ++ @patterns.constraints
        loc . (envConstraints, assumptions)       = eqAssEnv @expression.assumptions @patterns.environment @cinfoBind
        patterns . betaUnique   = @lhs.betaUnique + 1
        loc . beta              = integer2Name @lhs.betaUnique
        loc . fConstraint       = Constraint_Unify (foldr ((:-->:).var) (var @expression.beta) @patterns.betas) (var @beta) (Just @cinfoType)
    | Tuple
        lhs . touchables        = @beta : @expressions.touchables
        lhs . constraints       = @constraint : @expressions.constraints
        loc . constraint        = Constraint_Unify (var @beta) (monotypeTuple (map var @expressions.betas)) (Just @cinfo)
        loc . beta              = integer2Name @lhs.betaUnique
        expressions . betaUnique = @lhs.betaUnique + 1
    | List
        lhs . touchables        = @elemBeta : @beta : @expressions.touchables
        lhs . constraints       = @lstConstraints ++ @expressions.constraints
        expressions . betaUnique = @lhs.betaUnique + 2
        loc . elemBeta          = integer2Name @lhs.betaUnique
        loc . beta              = integer2Name (@lhs.betaUnique + 1)
        loc . lstConstraints    = Constraint_Unify (var @beta) (monotypeList (var @elemBeta)) (Just @cinfoResult) : zipWith (\b nr -> unifyVar @elemBeta b (@cinfoElem nr)) @expressions.betas [0..]
    | Constructor
        lhs . touchables        = @beta : getTypeVariablesFromPolyType' @tp
        lhs . betaUnique        = @bu
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
        loc . (tp, bu)          = case M.lookup @name.self (valueConstructors @lhs.importEnvironment) of
                                    Nothing  -> internalError "TypeInferenceRules" "n/a" "Constructor not found"
                                    Just (ctp, _) -> freshen (@lhs.betaUnique + 1) $ tpSchemeToPolyType @tyFams ctp
        lhs . constraints       = [Constraint_Inst (var @beta) @tp (Just @cinfo)]
        loc . beta              = integer2Name @lhs.betaUnique
    | InfixApplication
        leftExpression . betaUnique = @lhs.betaUnique + 2
        lhs . touchables            = @beta : @betaResOp : @leftExpression.touchables ++ @operator.touchables ++ @rightExpression.touchables
        lhs . constraints           = @constraints ++ @leftExpression.constraints ++ @operator.constraints ++ @rightExpression.constraints
        loc . beta                  = integer2Name @lhs.betaUnique
        loc . betaResOp             = integer2Name $ @lhs.betaUnique + 1 
    	loc . conOperator           = Constraint_Unify 
                                        (var @operator.beta) 
                                        (var @leftExpression.beta :-->: (var @rightExpression.beta :-->: var @betaResOp)) 
                                        (Just @cinfoOperator)
        loc . constraints           = case (@leftExpression.section,@rightExpression.section) of
                                                (False,False) -> [ @conOperator, (unifyVar @betaResOp @beta @cinfoComplete)                        ]
                                                (True ,True ) -> [               (unifyVar @operator.beta @beta @cinfoEmpty)                        ]
                                                (False,True ) -> [ @conOperator, (Constraint_Unify (var @rightExpression.beta :-->: var @betaResOp) (var @beta)) (Just @cinfoRightSection)]
                                                (True ,False) -> [ @conOperator, (Constraint_Unify (var @leftExpression.beta  :-->: var @betaResOp) (var @beta)) (Just @cinfoLeftSection)]
    | Let
        declarations.betaUnique = @lhs.betaUnique + 1
        lhs . touchables        = @beta : @touchables
        lhs . constraints       = unifyVar @beta @expression.beta @cinfoType : @constraints
        lhs . bindingGroups     = []
        loc . beta              = integer2Name @lhs.betaUnique
        (
            loc . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            loc . constraints,
            lhs . betaUnique,
            _,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let inputBDG = id $! (@lhs.importEnvironment, False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @expression.touchables, Just (@expression.assumptions, @expression.constraints, @expression.gadtConstraints),  @declarations.typeErrors ++ @expression.typeErrors, @declarations.resolvedContraints ++ @expression.resolvedContraints ,@expression.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups
    | Case
        lhs . touchables              = @beta : @beta' : @expression.touchables ++ @alternatives.touchables
        lhs . constraints             = unifyVar @expression.beta @beta' @cinfo : @expression.constraints ++ @alternatives.constraints
        expression      . betaUnique  = @lhs.betaUnique + 2
        alternatives    . betaLeft    = @beta'
                        . betaRight   = @beta
        loc             . beta        = integer2Name @lhs.betaUnique
                        . beta'       = integer2Name $ @lhs.betaUnique + 1
    | Typed 
        expression . betaUnique         = @bu'
        lhs . touchables                = @beta : @expression.touchables
        lhs . constraints               =   [
                                                unifyVar @beta @expression.beta @cinfoExpr ,
                                                Constraint_Inst (var @beta) @tp' (Just @cinfoResult )
                                            ] ++ @expression.constraints
        loc . beta                      = integer2Name @lhs.betaUnique
        loc . (tp', bu')                = freshen @bu (unbindPolyType @tp)
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
        loc . (tp, bu, mapping)         = typeToPolytype @tyFams (@lhs.betaUnique + 1) @type.self
    | Comprehension
        lhs . constraints           = @newcon : @qualifiers.constraints
        lhs . touchables            = @beta : @expression.touchables ++ @qualifiers.touchables
        expression  . betaUnique    = @lhs.betaUnique + 1
        qualifiers  . assumptions   = @expression.assumptions
                    . constraints   = @expression.constraints
        loc         . assumptions   = @qualifiers.assumptions
                    . beta          = integer2Name @lhs.betaUnique
                    . newcon        = Constraint_Unify (monotypeList (var @expression.beta)) (var @beta) (Just @cinfo)
    | Enum
        loc . beta                  = integer2Name @lhs.betaUnique
        loc . betaElem              = integer2Name $ @lhs.betaUnique + 1
        from . betaUnique           = @lhs.betaUnique + 2
        lhs . touchables            = @beta : @betaElem : @from.touchables ++ @then.touchables ++ @to.touchables
        lhs . constraints           =   [
                                            Constraint_Unify (monotypeList (var @betaElem)) (var @beta) (Just @cinfoResult),
                                            Constraint_Unify (var @betaElem) (var @from.beta) (Just @cinfoFrom),
                                            Constraint_Unify (var @betaElem) (var @then.beta) (Just @cinfoThen),
                                            Constraint_Unify (var @betaElem) (var @to.beta) (Just @cinfoTo),
                                            Constraint_Class "Enum" [var @betaElem] (Just @cinfoPred)
                                        ] ++ @from.constraints ++ @then.constraints ++ @to.constraints
    | Negate  
        expression . betaUnique     =   @lhs.betaUnique + 1
        lhs . touchables            =   @beta : @expression.touchables
        lhs . constraints           =   [Constraint_Inst (var @expression.beta :-->: var @beta) @tp (Just @cinfo)] ++ @expression.constraints
        loc . beta                  =   integer2Name @lhs.betaUnique
        loc . tyFams = typeSynonymsToTypeFamilies (typeSynonyms @lhs.importEnvironment) ++ obtainTyFams (M.elems $ typeFamDeclEnvironment @lhs.importEnvironment)
        loc . (tp, bu)              =   let standard = PolyType_Mono [Constraint_Class "Num" [var $ integer2Name 0] (Just @cinfo)] ((var $ integer2Name 0) :-->: (var $ integer2Name 0))
                                        in freshen (@lhs.betaUnique + 1) $ M.findWithDefault standard (nameFromString "negate") (tpSchemeToPolyType @tyFams <$> typeEnvironment @lhs.importEnvironment)
    | NegateFloat 
        expression . betaUnique     = @lhs.betaUnique + 1
        lhs . touchables            = @beta : @expression.touchables
        lhs . constraints           = 
                                        [
                                            Constraint_Unify 
                                                (MonoType_Con "Float" :-->: MonoType_Con "Float") 
                                                (var @expression.beta :-->: var @beta)
                                                (Just @cinfo)
                                        ] ++ @expression.constraints
        loc . beta                  = integer2Name @lhs.betaUnique

    | Do 
        statements . betaUnique     = @lhs.betaUnique + 3
        statements . generatorBeta  = Nothing
        statements . monadBeta      = var @betaMonad
        statements . assumptions    = M.empty
        statements . constraints    = []
        statements . touchables     = []
        statements . gadtConstraints= []
        loc . beta                  = integer2Name @lhs.betaUnique
        loc . betaMonad             = integer2Name $ @lhs.betaUnique + 1
        loc . betaVar               = integer2Name $ @lhs.betaUnique + 2
        lhs . constraints           =   [
                                            Constraint_Unify (var @beta) (MonoType_App (var @betaMonad) (var @betaVar)) (Just @cinfo),
                                            Constraint_Class "Monad" [var @betaMonad] (Just @cinfo)
                                        ] ++ maybe [] (\b -> [Constraint_Unify (var @beta) (var b) (Just @cinfo)]) @statements.generatorBeta ++ @statements.constraints
                                        

ATTR Statements Statement [ monadBeta : {MonoType} | touchables : {[TyVar]} generatorBeta : {Maybe TyVar} assumptions : Assumptions constraints:Constraints substitutionCollect : Substitution gadtConstraints : GADTConstraints | ]

SEM Statement 
    | Expression
        expression . betaUnique = @lhs.betaUnique + 2
        loc . beta              = integer2Name @lhs.betaUnique
        loc . betaRes           = integer2Name $ @lhs.betaUnique + 1
        lhs . generatorBeta     = Just @beta
        lhs . touchables        = @beta : @betaRes : @expression.touchables ++ @lhs.touchables
        lhs . assumptions       = @lhs.assumptions `combineAssumptions` @expression.assumptions
        lhs . constraints       =   [
                                        Constraint_Unify (var @expression.beta) (var @beta) (Just @cinfo), 
                                        Constraint_Unify (var @beta) (MonoType_App @lhs.monadBeta (var @betaRes)) (Just @cinfo)
                                    ] ++ @expression.constraints ++ @lhs.constraints
    | Generator 
        lhs . generatorBeta         = Nothing
        lhs . betaUnique            = @expression.betaUnique
        lhs . assumptions           = @assumptions' `combineAssumptions` @expression.assumptions
        lhs . constraints           = Constraint_Unify (var @expression.beta) (MonoType_App @lhs.monadBeta (var @pattern.beta)) (Just @cinfoResult) : 
                                            @envConstraints ++ @expression.constraints ++ @pattern.constraints ++ @lhs.constraints
        lhs . touchables            = @expression.touchables ++ @pattern.touchables ++ @lhs.touchables
        pattern . betaUnique        = @lhs.betaUnique + 2
        expression . betaUnique     = @pattern.betaUnique
        loc . (envConstraints, assumptions')          = eqAssEnv @lhs.assumptions @pattern.environment @cinfoBind
    | Let 
        lhs . generatorBeta  = Nothing
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            lhs . constraints,
            lhs . betaUnique,
            _,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let inputBDG = id $! (@lhs.importEnvironment, False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.gadtConstraints), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

SEM Statements

    | Cons
        lhs . assumptions = @hd.assumptions
            . constraints = @hd.constraints
            . touchables  = @hd.touchables
            . betaUnique = @hd.betaUnique
        hd  . assumptions = @tl.assumptions
            . constraints = @tl.constraints
            . touchables  = @tl.touchables
            . betaUnique = @tl.betaUnique
        tl  . assumptions = @lhs.assumptions
            . constraints = @lhs.constraints
            . touchables = @lhs.touchables
            . betaUnique = @lhs.betaUnique

ATTR Alternative Alternatives [ betaLeft:TyVar betaRight:TyVar | caseArmIndex:Int | ]

SEM Alternatives
    | Cons
        hd  . caseArmIndex      = @tl.caseArmIndex
        lhs . caseArmIndex      = @hd.caseArmIndex + 1
    | Nil
        lhs . caseArmIndex = 0

SEM Alternative
    | Alternative
        lhs . constraints = if null @pattern.gadtVariables then 
                                unifyVar @pattern.beta @lhs.betaLeft @cinfoLeft : @envConstraints ++ @pattern.constraints ++ @righthandside.constraints
                            else
                                [unifyVar @pattern.beta @lhs.betaLeft @cinfoLeft]
        lhs . assumptions = if null @pattern.gadtVariables then @assumptions else M.empty
        loc . (envConstraints, assumptions) = eqAssEnv @righthandside.assumptions @pattern.environment @cinfoBind
        lhs . gadtConstraints = if null @pattern.gadtVariables then 
                                    @subGADTConstraints 
                                else
                                    [GADTConstraint @lhs.caseArmIndex
                                        (@righthandside.touchables ++ @pattern.gadtVariables)
                                        @pattern.gadtAssumeConstraints
                                        (@pattern.gadtCondition ++ @righthandside.constraints ++ @envConstraints)
                                        @assumptions
                                        @subGADTConstraints
                                        emptyConstraintInfo
                                    ]
                                     
        loc . subGADTConstraints = map (resolveEnv @pattern.environment) @righthandside.gadtConstraints

ATTR Qualifier Qualifiers [ |  touchables : {[TyVar]} assumptions:Assumptions constraints:Constraints substitutionCollect : Substitution gadtConstraints : GADTConstraints | ]

SEM Qualifier
    | Guard
        lhs . touchables = @guard.touchables ++ @lhs.touchables
        lhs . assumptions = @lhs.assumptions `combineAssumptions` @guard.assumptions
        lhs . constraints =  Constraint_Unify (var @guard.beta) (MonoType_Con "Bool") (Just @cinfo) : @guard.constraints ++ @lhs.constraints
    | Generator
        lhs . touchables        = @expression.touchables ++ @pattern.touchables ++ @lhs.touchables
        lhs . assumptions       = @assumptions' `combineAssumptions` @expression.assumptions
        lhs . constraints       = @newcon : @envConstraints ++ @pattern.constraints ++ @expression.constraints ++ @lhs.constraints
        loc . newcon            = Constraint_Unify (var @expression.beta) (monotypeList (var @pattern.beta)) (Just @cinfoResult)
        loc . (envConstraints, assumptions') = eqAssEnv @lhs.assumptions @pattern.environment @cinfoBind
    | Let
        lhs . bindingGroups     = []
        (
            lhs . touchables,
            lhs . assumptions,
            lhs . typeSignaturesCollect,
            lhs . constraints,
            lhs . betaUnique,
            _,
            lhs . typeErrors,
            lhs . resolvedContraints
        ) =
            let inputBDG = id $! (@lhs.importEnvironment, False, @lhs.axioms, @declarations.typeSignaturesCollect `M.union` (@lhs.typeSignatures M.\\ @declarations.environment), @declarations.touchables ++ @lhs.touchables, Just (@lhs.assumptions, @lhs.constraints, @lhs.gadtConstraints), @declarations.typeErrors, @declarations.resolvedContraints, @declarations.betaUnique)
            in bindingGroupAnalysis inputBDG @declarations.bindingGroups

SEM Qualifiers

  | Cons
        lhs . assumptions = @hd.assumptions
            . constraints = @hd.constraints
            . touchables  = @hd.touchables
            . betaUnique = @hd.betaUnique
        hd  . assumptions = @tl.assumptions
            . constraints = @tl.constraints
            . touchables  = @tl.touchables
            . betaUnique = @tl.betaUnique
        tl  . assumptions = @lhs.assumptions
            . constraints = @lhs.constraints
            . touchables = @lhs.touchables
            . betaUnique = @lhs.betaUnique



ATTR MaybeExpression [ | | section : Bool]          

SEM MaybeExpression

  | Just
      lhs . section = False

  | Nothing
      lhs . touchables  = [@beta]
      lhs . section     = True
          . betaUnique  = @lhs.betaUnique + 1
      loc . beta        = integer2Name @lhs.betaUnique
      


ATTR Literal [ | | literalType : MonoType floatValue : Float]

SEM Literal
    | Int
        lhs . literalType   = MonoType_Con "Int"
    | Float
        lhs . literalType   = MonoType_Con "Float"
        lhs . floatValue    = read @value
    | String
        lhs . literalType   = MonoType_Fam "String" []
    | Char
        lhs . literalType   = MonoType_Con "Char"
              
{

}

