-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
--
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Collect the following information:
--
--    1) dimension type synonyms
--    2) record declarations
--    3) type classes and their declarations
--
-- Adaptation of Collect.ag for unit information
-- A bit more simple since we do not deal with imports and constructors
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

-- WÐµ have to collect first declared information

 -- 1) Collecting dimension type synonyms

ATTR Body Declaration Declarations 
    [ | collectDimTypeSynonyms : { [(Name, (Int, [UnitType] -> UnitType))} ]

SEM Module | Module   body . collectDimTypeSynonyms = [] -- why ?


SEM Declaration
    | Type   lhs . collectDimTypeSynonyms = (@simpletype.name, @dimtypeSynonymInfo) : @lhs.collectDimTypeSynonyms
             loc . dimtypeSynonymInfo = (@simpletype.name,
                (length @simpletype.typevariables utlist, -- pretty sure I don't need it
                \utlist ->
                    makeUnitTypeFromType (zip @simpletype.typevariables tps) @type.self

                ))

-------------------------------------------------------------------------------
 -- 2) Collecting record fields

-- We only have to check fields. 
-- Records are far more simpler in this version, since we only
-- have to check fields (the record constructor is just Undim -> Undim )
-- We have to check:
-- the dimension of what is computed
-- consistance of the field type with the arguments of the father type
-- e.g. data Type a = Cons { field1 : a -> Int, field2 : a}
-- we can't write 
-- record = Cons { field1 = \x -> x + 1 <Metre>, field2 = 2 <Second> }
-- record is inferred of type Type a and then this is the same variable for the other
-- we just have to understand that in the fileDeclarations, there is a father type
-- and that we should unify over those type variables and take care

ATTR Body Declarations Declaration Constructor Constructors [ | 
  | collectFields USE { M.union } { M.empty } : { M.Map Name (M.Map Name ( [UTp Unit] -> UTp Unit)) } ]


SEM Constructor
    | Constructor   lhs.collectDimRecord = M.singleton @constructor.self M.empty
    | Record        lhs.collectDimRecord = 

SEM FieldDeclaration
    | FieldDeclaration      lhs.unitTypeFromFieldDecl = [(name,
                                 \utlist -> 
                                    foldl to
                                    [makeUnitTypeFromType @type.self])
                                | name <- @names.self
                                ]

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- 3) Collecting the classes

-- In our specific case, we do not have to collect instances. The type variable is either 1 or Undimensioned
-- We can make a UITVar which can only take Undimensioned or 1 as dimension. Not very satisfying but that works.
-- We don't have to care about anything else. Being an instance or not is already verified in the undim. part.

ATTR Declarations Declaration
    [ | | dimClassVariables USE {M.union} {M.empty} : UnitEnvironment ]

SEM Declaration
    | Class                  lhs.dimClassVariables = @where.dimensionSignature


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-- 4) Collecting the type signatures


ATTR MaybeDeclarations Declarations Declaration
    [ | | dimSignature USE {M.union} {M.empty} : {UnitEnvironment}}]

SEM Declaration
    | TypeSignature          lhs . dimSignature = [ (name, @dimType) | name <- @names.self ] ++ @lhs.dimSignature
                             loc . dimType = makeUnitTypeFromType @type.self

{

makeUnitTypeFromType :: [(Name, UnitType)] -> Type -> UnitType
makeUnitTypeFromType nameMap = rec_
  where
        rec_ :: Type -> UnitType
        rec_ uhaType = case uhaType of
             Type_Application _ _ fun args -> foldl UTApp (rec_ fun) (map rec_ args)
             Type_Variable _ name _        -> fromMaybe Undimensioned (lookup name nameMap)
             Type_Constructor _ name ut    -> ut
             Type_Parenthesized _ t        -> rec_ t
             Type_Qualified _ _ t          -> rec_ t
             Type_Forall{}                 -> internalError "TypeConversion.hs" "makeTpFromType" "universal types are currently not supported"
             Type_Exists{}                 -> internalError "TypeConversion.hs" "makeTpFromType" "existential types are currently not supported"


makeUnitTypeFromAnnotatedType :: [(Name, UnitType)] -> AnnotatedType -> UnitType
makeUnitTypeFromAnnotatedType nameMap annotatedType =
    let AnnotatedType_AnnotatedType _ _ t = annotatedType in
    makeUnitTypeFromType t

}