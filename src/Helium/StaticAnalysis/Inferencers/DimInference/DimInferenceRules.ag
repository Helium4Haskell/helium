-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
-- 
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Contains all the dimension type system rules for a dimensioned UHA ST
--
------------------------------------------------------------------------------

INCLUDE "UHA_Syntax.ag"

imports{
import Data.Char
import Data.Map
import Helium.Syntax.UHA_Syntax
import Helium.Utils.Utils (internalError, hole)
}

{-

 SUMMARY OF THE DIMENSION INFERENCE:
 We proceed step by step:
 - Attribute an unique identifier for each unit variable
 - Store the known dimension of the expressions (expressed with those variables)
 - Store each unit constraints
 - Normalization of units and solver of constraints
 - Display error message from unit constraint
 - Go through the AST and labelled each expression with units / stored each variable units in a map

HYPOTHESIS:
- NO TYPE ERROR
- EVERY DIMENSIONED OBJECT HAS TYPE INT OR FLOAT
CONSEQUENCES:
- NO DATA STRUCTURE CAN HAVE A DIMENSION (IN PARTICULAR LIST, TUPLE, RECORD...)
-}


{
data UnitEnvironment = M.Map Name UnitType
}


---------------------------- Used Attributes ------------------------------

ATTR Type SimpleType AnnotatedType
    [ | | dimTypeInfo : { UnitType } ]

ATTR Expression RightHandSide --...
    [ | | dimExprInfo : { UnitType } ]

ATTR 
    [ variableToDim : UnitEnvironment
      typeToDim : UnitEnvironment
      typeConstructorToDim : UnitEnvironment
      unitConstraints USE {++} {[]} : UnitConstraints | | ]

-- ------------------------------------------------------------------------
-- -- Declarations                                                        --
-- ------------------------------------------------------------------------

ATTR Declarations Declaration
    [ | | 
      variableToDim USE {M.union} {M.empty} : UnitEnvironment
      unitConstraints USE {++} {[]} : UnitConstraints]

SEM Declaration

    | Instance          lhs.variableToDim = @where.variableToDim 
                        lhs.unitConstraints = @where.constraints
                        
    | FunctionBindings  lhs.variableToDim = M.union @bindings.variableToDim @lhs.variableToDim
    --  range                    : Range
    --  bindings                 : FunctionBindings
    | PatternBinding    lhs.variableToDim = M.union @lhs.variableToDim @pattern.patternVariableDim
    --  range                    : Range
    --  pattern                  : Pattern
    --  righthandside            : RightHandSide
    | TypeSignature     lhs.variableToDim = map (\n -> M.insert n @type.dimTypeInfo @lhs.variableToDim) @names
    --  range                    : Range
    --  names                    : Names
    --  type                     : Type

    | Unit              lhs.unitConstraints = [(@associatedcv.dimExpr, Arrow (makeUnitTypeFromType [] (Base @associatedunit.self)) (Base @simpletype.name))]

-- ------------------------------------------------------------------------
-- -- Expressions                                                        --
-- ------------------------------------------------------------------------

ATTR Expression Expressions MaybeExpression [ betaUnique:Int | assumptions:Assumptions ]
ATTR Expression                             [ | | beta:Tp constraints:ConstraintSet ]
ATTR            Expressions                 [ | | betas:Tps constraintslist:ConstraintSets ]
ATTR                        MaybeExpression [ | | beta:Tp constraints:ConstraintSet section:Bool ]


SEM MaybeExpression
    | Nothing
    | Just          loc.text = Just @expression.text
    --  expression               : Expression


{- We need two piece of infos:
- the dimension of the expression
- the constraints it raises -}

SEM Expression
    | Literal            lhs.dimExpr = Undimensioned
    | Constructor        lhs.dimExpr = Undimensioned
                         {-   case M.lookup name @collectValueDimConstructors of
                                Just a -> a -- (par1 -> par2 -> .. -> parn -> mothertype)
                                Nothing -> internalError "Constructor undefined ?" -}

    | Variable           loc . beta = UTVar @lhs.betaDeclUnique
                         lhs .(dimExpr, unitConstraints) = 
                            case M.lookup name @lhs.variableToDim of
                                Nothing -> @beta, []
                                Just a -> a, [(@beta,a)]

    | NormalApplication  lhs . (dimExpr, unitConstraints) = 
                            let (expectedArgUT, resultUT) = ufunctionSpine @function.dimExpr in
                                let appConstraints, unitType =
                                    constraintFromApp expectedArgUT resultUT @arguments.dimExpr
                                in
                                (unitType,
                                 appConstraints ++ @function.constraints ++ @arguments.constraints)

    | InfixApplication   loc. (dimExpr, unitConstraints) = 
                            let (expectedArgUT, resultUT) = ufunctionSpine @function.dimExpr in
                                let appConstraints, unitType =
                                    constraintFromApp expectedArgUT resultUT [@leftExpression.dimExpr, @rightExpression.dimExpr]
                                in
                                (unitType,
                                appConstraints ++ @operator.constraints ++
                                @leftExpression.constraints ++ @rightExpression.constraints
                                )

    | If                 loc . thenDim = @thenExpression.dimExpr
                             . elseDim = @elseExpression.dimExpr
                         lhs . dimExpr = @thenExpression.dimExpr
                         lhs . unitConstraints = [(@thenDim, @elseDim)]
                            ++ @thenExpression.unitConstraints ++ @elseExpression.unitConstraints
                            ++ @guardExpression.unitConstraints

    | Lambda             expression.varToDim = M.union @patterns.patternVariablesDim @lhs.varToDim
                         lhs . dimExpr = Arrow @patterns.patternsDimType @expression.dimExpr
                             . unitConstraints = @patterns.patternVariableDim ++ @expression.unitConstraints
    | Case              alternatives.patternDimType  = @expression.dimExpr
                        lhs.(unitConstraints, dimExpr) =
                            let uc, dimexpr = constraintUnifiedList @alternatives.dimExpr in
                            ( uc ++ @expression.unitConstraints ++ @alternatives.unitConstraints,
                                    @alternativeDimRef)
                             
    | Let               loc.beta = TVar @lhs.betaDeclUnique
                        expression.variableToDim = M.union @declarations.variableToDim @lhs.variableToDim
                        lhs.unitConstraints =
                            [(@beta, @expression.dimExpr)]
                            @declarations.unitConstraints ++
                            @expression.unitConstraints

    | List              lhs . dimExpr = listUType @expressions.dimExprInfo
                        loc . unitConstraints = -- everything should have the same unit
                            case @expressions.dimExprInfo of
                                []  -> []
                                [a] -> []
                                t:q -> [ (t,x) | x <- q ]

    | Tuple             lhs . dimExpr =  Tuple @expressions.dimExprInfo
                        -- lhs . unitConstraints = @expressions.unitConstraints
    | Typed             loc . dimtype = @type.dimTypeInfo
                            . dimExpr = @expression.dimExprInfo
                        lhs . unitConstraints = [ (@dimtype, @dimExpr) ]
    | Dimensioned       lhs.unitConstraints = [(@expression.dimExprInfo, Base @unit.self)] ++ @expressions.unitConstraints
    | Negate NegateFloat        lhs.dimExpr = @expression.dimExpr
                                lhs.unitConstraints = @expression.UnitConstraints
    | Do                -- lhs.unitConstraints = @statements.unitConstraints
                        -- @statements.variableToDim = @lhs.variableToDim
    | Enum              lhs.unitConstraints =
                            @from.unitConstraints ++
                            @then.unitConstraints ++
                            @else.unitConstraints ++
                            @loc.thenConstraints ++
                            @loc.toConstraints
                        loc.thenConstraints = 
                            if then.isNothing then [] else [(@from.dimExpr,@then.dimExpr)]
                        loc.toConstraints = 
                            if to.isNothing then [] else [(@from.dimExpr,@to.dimExpr)]
                        lhs.dimExpr =
                            UTApp "[]" @from.dimExpr
    
    | Comprehension     lhs.dimExpr = @expression.dimExpr
                        lhs.unitConstraints = @qualifiers.unitConstraints ++ @expression.unitConstraints
    | RecordConstruction lhs.dimExpr, recordExpressionBindings.parameter = 
                            case M.lookup @name.self @lhs.collectValueDimConstructors of
                                Just (_, (n, parameter)) -> n, parameter
                         lhs.unitConstraints = @recordExpressionBindings.unitConstraints
    --  range                    : Range
    --  name                     : Name
    --  recordExpressionBindings : RecordExpressionBindings
    | RecordUpdate               lhs.unitConstraints = @expression.unitConstraints ++ @recordExpressionBindings.unitConstraints
                                    ++ [unitTypeField @recordExpressionBindings.name @expression.self, @recordExpressionBindings.dimExpr]
    --  range                    : Range
    --  expression               : Expression
    --  recordExpressionBindings : RecordExpressionBindings


{

constraintFromApp :: [UTp Unit] -> UTp Unit -> [UTp Unit] -> UnitConstraints -> UTp Unit
constraintFromApp expectedArgUT resultUT receivedArgUT =
    case (expectedArgUT, receivedArgUT) of
        (t:q, []) -> ([], expectedArgUT to resultUT)
        (t1:q1), (t2:q2) ->
            let constraints, unitType = constraintFromApp q1 resut q2 in
            ( (t1,t2):constraints, unitType)

-- terminal recursivity possible there


unitTypeField :: Name -> UnitType -> UnitType
unitTypeField n ut =
    case ut of -- ORDERING???

}


---------------------------------------------------------------------------

SEM Statements
    |Cons           @tl.variableToDim = @hd.variableToDim
                    @hd.variableToDim = @lhs.variableToDim

SEM Statement
    | Expression        lhs.unitConstraints = @expression.unitConstraints
                        lhs.dimExpr = @expression.dimExpr
    | Let               lhs.variableToDim = M.union @declarations.variableToDim  @lhs.variableToDim
    | Generator         lhs.unitConstraints = @expression.unitConstraints
                        lhs.variableToDim = M.union
                            @lhs.variableToDim 
                            (M.fromList @patternpatternVariableDim)

SEM Qualifier
    | Guard               -- lhs.unitConstraints = @guard.unitConstraints
    | Let                 lhs.variableToDim = M.union @declarations.variableToDim @lhs.variableToDim
                            -- I am not even sure we need an union since declarations one contains the other
    --  range                    : Range
    --  declarations             : Declarations
    | Generator           -- lhs.unitConstraints = @expression.unitConstraints
                        lhs.variableToDim = M.union @pattern.patternVariableDim @lhs.variableToDim
                        -- check the expression and attribute to the pattern the values
    
SEM Alternative
    | Alternative       lhs.dimExpr = @righthandside.dimExpr
                        righthandside.variableToDim = M.union @lhs.variableToDim (fromList @pattern.patternVariableDim)
                        lhs.unitConstraints = @righthandside.unitConstraints

SEM GuardedExpression
    | GuardedExpression lhs.unitConstraints = @guard.unitConstraints ++ @expression.unitConstraints
                        lhs.dimExpr = @expression.dimExpr

SEM RecordExpressionBinding
    | RecordExpressionBinding lhs.unitConstraints, expression.variableToDim =
                                case M.lookup @name.self @lhs.collectDimRecordConstructors of
                                    recordConsUnit -> [(recordConsUnit, @expression.dimExpr)]++@expression.unitConstraints



---------------------------------------------------------------------------------------------------------

SEM FunctionBinding
    | FunctionBinding   (lhs.unitConstraints, lefthandside.declUnit) =
                            case M.lookup @functionName @lhs.variableToDim of
                                Nothing -> @righthandside.unitConstraints, []
                                Just ut@(Arrow argsut resut) ->
                                    (@righthandside.dimExpr, resut):@righthandside.constraint, -- We'll see[(a,righthandside.dimExpr) |  ]
                        righthandside.variableToDim = M.union
                            @lhs.variableToDim
                            (fromList @argsDimType)
                        loc . functionName = @lefthandside.name
                        loc . argsDimType = @lefthandside.patternVariablesDim

-- the way we will proceed is the following:
-- We will only update the environment with those variables so
-- there is nothing else to return than the environment and the name of the function

-- not sure, maybe there is some checks there:
SEM LeftHandSide
    | Function          lhs.name = @name.self
                        patterns.list =
                            case M.lookup @name.self @lhs.variableToDim of
                                Nothing -> [ Undimensioned | x <- @patterns.self]
                                Just (Arrow lunit) -> lunit
                        lhs.patternVariablesDim = @patterns.patternVariablesDim

    | Infix            lhs.name = @operator.self
                       lhs.patternVariablesDim = @leftPattern.patternVariablesDim ++ @rightPattern.patternVariablesDim

    | Parenthesized    lhs.name = @lefthandside.name
                       lhs.patternVariablesDim = @lefthandside.patternVariablesDim ++ @patterns.patternVariablesDim


SEM RightHandSide
    | expression           expression.variableToDim = M.union @where.variableToDim @lhs.variableToDim
                           -- expression.typeToDim = M.union @where.variableToDim @lhs.variableToDim
                           -- no typeToDim in where I think, type decl are top level
                           lhs.unitConstraints = @expression.UnitConstraints
                           lhs.dimExpr = @expression.dimExpr
    --  range                    : Range
    --  expression               : Expression
    --  where                    : MaybeDeclarations

    | Guarded               lhs.unitConstraints = @guardedexpressions.unitConstraints
                            lhs.(unitConstraints, dimExpr) =
                                let uc, dimexpr = constraintUnifiedList @guardedexpressions.dimExpr in
                                (uc ++ @guardedexpressions.unitConstraints, dimexpr)
                            @guardedexpressions.variableToDim = M.union @where.variableToDim @lhs.vari
    --  range                    : Range
    --  guardedexpressions       : GuardedExpressions
    --  where                    : MaybeDeclarations

{

constraintUnifiedList :: [UnitType] -> (UnitConstraints, UnitType)
constraintUnifiedList utlist =
    case utlist of
        [] -> ([], Undimensioned) -- not supposed to happen
        [a] -> ([], a)
        dimRef:otherDim -> ([(dimRef, dim) | dim <- otherDim ], dimRef)


}

-- ------------------------------------------------------------------------
-- -- Patterns                                                           --
-- ------------------------------------------------------------------------

ATTR Patterns
    [ list : [] | | ]

ATTR Pattern
    [ | | patternVariableDim USE { ++ } { [] }: [(Name,UnitType)] ]


SEM Patterns
    | Cons          (hd.declUnit, tl.list) =
                        case @lhs.list of
                            t:q -> Just t,q
                    lhs.patternsDimType = @hd.dimtype:@tl.patternsDimType


-- No variable environment, only a type environment for Constructors
-- The only explicitely dimensioned variables in a pattern are under a dimensioned
-- type constructor.
-- No unification to be done when crossing or leaving a pattern
-- We get the explicitely dimensioned variables in a pattern are under a dimensioned
-- type constructor.
-- declUnit field is Just u if its pattern is forced to be of a certain dimension
SEM Pattern
    | Variable              lhs.patternVariableDim = [(@name.self, @lhs.dimPatt)]
                            lhs.dimPatt = case @lhs.declUnit of
                                Nothing -> Undimensioned
                                Just u -> u
    | List                  lhs.patternVariableDim = @patterns.patternVariableDim
                            lhs.dimPatt = List @patterns.dimPatt
                            patterns.list = case @lhs.declUnit of
                                List unit -> [unit | x <- @patterns.self] --other cases are impossible (type checked)
        range                    : Range
        patterns                 : Patterns
    | Tuple                 lhs.patternVariableDim = @patterns.patternVariableDim
                            lhs.dimPatt = Tuple @patterns.dimPatt
                            patterns.list = [Undimensioned | x <- patterns.self]
        range                    : Range
        patterns                 : Patterns
    | As                    lhs.patternVariableDim = [(@name.self, @pattern.dimPatt)]++@pattern.patternVariableDim
                            pattern.declUnit = @lhs.declUnit
        range                    : Range
        name                     : Name
        pattern                  : Pattern
    | Constructor           patterns.list, lhs.dimPatt = [], Undimensioned

                            {-(patterns.list, lhs.dimPatt) =
                                case M.lookup @name.self @typeToDim of
                                    Just (Cons name list) -> list, Cons name list
                                    Nothing -> [], Undimensioned
                            lhs.patternVariableDim = @patterns.patternVariableDim-}
        range                    : Range
        name                     : Name
        patterns                 : Patterns
    | InfixConstructor      lhs.dimPatt = List @constructorOperator.dimtype
                            leftPattern.declUnit, rightPattern.declUnit = 
                                case M.lookup @constructorOperator.name @lhs.typeToDim of
                                    Just (InfixConstructor utleft utright) -> utleft, utright
        range                    : Range
        leftPattern              : Pattern
        constructorOperator      : Name
        rightPattern             : Pattern
    -- TAKE CARE TO THE ORDER, NOT SURE THAT'S IMPORTANT FOR RECORDS
    | Record                lhs.dimPatt = Record @recordPatternBindings.dimPatt
                            recordPatternBindings.declUnit =
                                case M.lookup @name.self @lhs.collectDimRecordConstructors of
                                    Just (Record fieldToUtList) -> fieldToUtList
        range                    : Range
        name                     : Name
        recordPatternBindings    : RecordPatternBindings


-- not necessary rule I think
SEM RecordPatternBinding
    | Cons          lhs.dimPatt = @hd.dimPatt : @tl.dimPatt
                    lhs.unitConstraints = @hd.unitConstraints : @tl.unitConstraints
                    hd.expectedDimType, tl.expectedDimType =
                        case @declUnit of
                            t:q -> t,q
                            [] -> internalError "Missing field" 
                            -- really ? should we have every fields there ?

SEM RecordPatternBinding
    | RecordPatternBinding  -- loc.expectedUnit = unitTypeField @name.self @lhs.declUnit (IF NO ORDERING)
                            lhs.unitConstraints =
                                (@lhs.expectedDimType, @pattern.dimPatt)
                                : @pattern.unitConstraints
    --  range                    : Range
    --  name                     : Name
    --  pattern                  : Pattern

-- ------------------------------------------------------------------------
-- -- Types                                                              --
-- ------------------------------------------------------------------------

-- We return an information about the type if the dimension

SEM Type
    | Application             lhs . dimTypeInfo = Arrow @function.dimTypeInfo @arguments.dimTypeInfo
    --  range                    : Range
    --  prefix                   : Bool
    --  function                 : Type 
    --  arguments                : Types
    | Variable                lhs . (dimTypeInfo, typeToDim) =
                                    case @unit.self of
                                        Nothing -> Undimensioned, @lhs.typeToDim
                                        Just u -> Base u, M.insert @lhs.dimTypeInfo @name @lhs.typeToDim
    --  range                    : Range
    --  name                     : Name
    --  unit                     : MaybeUnit
    | Constructor              lhs.dimTypeInfo = Base @unit.self
                               lhs.typeToDim = M.insert @lhs.dimTypeInfo @lhs.typeToDim
    --  range                    : Range
    --  name                     : Name
    --  unit                     : MaybeUnit
    | Parenthesized            lhs.dimTypeInfo = @type.dimTypeInfo
                               lhs.typeToDim = @type.typeToDim
    --  range                    : Range
    --  type                     : Type
    | Qualified                lhs.dimTypeInfo = @type.dimTypeInfo
                               lhs.typeToDim = @type.typeToDim
    --  range                    : Range
    --  context                  : ContextItems
    --  type                     : Type

SEM SimpleType
    | SimpleType         lhs.dimTypeInfo = M.lookup @name.self @lhs.typeToDim
    --  name                     : Name
    --  typevariables            : Names

SEM ContextItem -- What is that?
    | ContextItem       loc.text = @name.text <+> head @types.text -- no parens because it is always a var
    --  range                    : Range
    --  name                     : Name   -- that is the class
    --  types                    : Types  -- in Haskell 98, this is only one type

SEM Constructor
    | Constructor       
    --  range                    : Range
    --  constructor              : Name
    --  types                    : AnnotatedTypes
    | Infix             
    --  range                    : Range
    --  leftType                 : AnnotatedType
    --  constructorOperator      : Name
    --  rightType                : AnnotatedType
    | Record            
    --  range                    : Range
    --  constructor              : Name
    --  fieldDeclarations        : FieldDeclarations

-- This is in a record; what do we do with records? : well, normal dim inference
SEM FieldDeclaration
    | FieldDeclaration      @lhs.typeToDim =
                                 fold (M.insert) @lhs.typeToDim
                                    [(n,t) | n <- @names.self, t <- @type.dimTypeInfo]
    --  range                    : Range
    --  names                    : Names
    --  type                     : AnnotatedType        

SEM AnnotatedType
    | AnnotatedType         @lhs.dimType = @type.dimTypeInfo


