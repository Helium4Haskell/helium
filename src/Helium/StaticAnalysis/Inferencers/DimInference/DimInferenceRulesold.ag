

INCLUDE "UHA_Syntax.ag"

imports{
-- Below two imports are to avoid clashes of "list" as used by the AG system.
-- Effectively, only list from the imported library needs to be qualified.
import Prelude hiding ((<$>))
import Text.PrettyPrint.Leijen hiding (list)
import qualified Text.PrettyPrint.Leijen as PPrint
import Data.Char
import Top.Types (isTupleConstructor)
import Helium.StaticAnalysis.Inferencers.DimInference.Unification(unify)

import Helium.Syntax.UHA_Syntax
import Helium.Utils.Utils (internalError, hole)

import qualified Data.Set as S
}

{-
For the whole program, we need a map storing the dimension of each expression;
 we add this information into the map for each dimensioned variable we encounter

 Those dimensions can depend from a variable unit - its unit will be infered 
 in the solver

( we may have to distribute those information then
 -> Take care about local information in a where
 UPDATE THE ENVIRONEMENT)
  Maybe I shouldn't be doing collect and inference together?


 You will have to make a more serious job with more serious rules from now...
 -> Mutual recursion to handle? A bit of study to be done there?

 We should proceed step by step:
 - Attribute an unique identifier for each unit variable
 - Store each unit constraints
 - Display eror message from unit constraint
 - Go through the AST and labelled each expression with units / stored each variable units in a map
-}

{
data UnitEnvironment = M.Map Name UnitType

data UnitConstraints = [(UnitType, UnitType)] -- both should be unified

}


---------------------------- Used Attributes ------------------------------

ATTR Type SimpleType AnnotatedType
    [ | | dimTypeInfo : { UnitType } ]

ATTR Expression RightHandSide ...
    [ | | dimExprInfo : { UnitType } ]

ATTR 
    [ variableToDim, typeToDim : UnitEnvironment
      unitConstraints USE {++} {[]} : UnitConstraints | | ]

-- Building a set of constraints



---------------------------------------------------------------------------
---------------------------------------------------------------------------
-- 2) Store each unit constraints
---------------------------------------------------------------------------
---------------------------------------------------------------------------

SEM Module
    | Module        -- get the errors
    --  range                    : Range
    --  name                     : MaybeName
    --  exports                  : MaybeExports
    --  body                     : Body

-- I think we do not need export (not sure, to check, what is it exactly?)

SEM Body
    | Hole                     -- Nothing
    | Body                     -- goto declarations
    --  range                    : Range
    --  importdeclarations       : ImportDeclarations
    --  declarations             : Declarations

-- We do not handle imports for units

SEM MaybeDeclarations
    | Nothing     -- Nothing
    | Just -- iter on the dimension (depends on the attribute)
    --  declarations             : Declarations

SEM Declaration
    | Hole              -- Nothing
    | Dimension         -- Nothing, already handled in static checks
    | UnitFromUnit      -- Nothing, already handled in static checks
    | AliasUnit         -- Nothing, already handled in static checks
    | Default           -- nothing, it appears that it not even parsed
    | Fixity            -- Nothing I think
    | Empty             -- Nothing

    | Type              @lhs.typeDimension = M.insert @simpletype.name @type.typeDimension @lhs.typeDimension
                        -- a bit more complicated because data MyMaybe a = Maybe a is allowed: can have parameter
    --  range                    : Range
    --  simpletype               : SimpleType
    --  type                     : Type
    | Data              @lhs.typeDimension = M.insert @simpletype.name @type.typeDimension @lhs.typeDimension
    
                        -- euhhh compliqué parce que le type est compliqué, on crée des data structure ici. 
                        -- Ca se fait mais ça demande du travail.
                        -- (je suis quand même en train de réaliser que c'est plus simple
                        -- de faire les deux en même temps car on doit refaire les mêmes explorations.)
    --  range                    : Range
    --  context                  : ContextItems
    --  simpletype               : SimpleType
    --  constructors             : Constructors
    --  derivings                : Names
    | Newtype           -- same
    --  range                    : Range
    --  context                  : ContextItems
    --  simpletype               : SimpleType
    --  constructor              : Constructor  -- has only one field, no strictness
    --  derivings                : Names
    | Class             lhs.variableDimension = M.union @where.variableDimension @lhs.variableDimension 
    --  range                    : Range
    --  context                  : ContextItems -- is a "simple" context
    --  simpletype               : SimpleType   -- Haskell 98 allows only one variable
    --  where                    : MaybeDeclarations -- cannot have everything
    | Instance          lhs.variableDimension = M.union @where.variableDimension @lhs.variableDimension 
    --  range                    : Range
    --  context                  : ContextItems -- is a "simple" context
    --  name                     : Name
    --  types                    : Types        -- Haskell 98 allows only one type
                                                -- that is severely restricted
    --  where                    : MaybeDeclarations -- cannot have everything
    | FunctionBindings  lhs.variableDimension
    --  range                    : Range          {- *** -}
    --  bindings                 : FunctionBindings 
    | PatternBinding        -- get the type from the pattern

    --  range                    : Range
    --  pattern                  : Pattern
    --  righthandside            : RightHandSide
    | TypeSignature     lhs.variableDimension = map (\n -> M.insert n @type.dimTypeInfo @lhs.variableDimension) @names
    --  range                    : Range
    --  names                    : Names
    --  type                     : Type

-- ------------------------------------------------------------------------
-- -- Types                                                              --
-- ------------------------------------------------------------------------

SEM Type                                         {- *** -}
    | Application             lhs . dimTypeInfo = Arrow @function.dimTypeInfo @arguments.dimTypeInfo
    --  range                    : Range
    --  prefix                   : Bool
    --  function                 : Type 
    --  arguments                : Types
    | Variable                lhs . (dimTypeInfo, typeDimension) =
                                    case @unit.self of
                                        Nothing -> Undimensioned, @lhs.typeDimension
                                        Just u -> Base u, M.insert @lhs.dimTypeInfo @name @lhs.typeDimension
    --  range                    : Range
    --  name                     : Name
    --  unit                     : MaybeUnit
    | Constructor              lhs.dimTypeInfo = Base @unit.self
                               lhs.typeDimension = M.insert @lhs.dimTypeInfo @lhs.typeDimension
    --  range                    : Range
    --  name                     : Name
    --  unit                     : MaybeUnit
    | Parenthesized            lhs.dimTypeInfo = @type.dimTypeInfo
                               lhs.typeDimension = @type.typeDimension
    --  range                    : Range
    --  type                     : Type
    | Qualified                lhs.dimTypeInfo = @type.dimTypeInfo
                               lhs.typeDimension = @type.typeDimension
    --  range                    : Range
    --  context                  : ContextItems
    --  type                     : Type

SEM SimpleType
    | SimpleType         lhs.dimTypeInfo = M.lookup @name.self @lhs.typeToDim
    --  name                     : Name
    --  typevariables            : Names

SEM ContextItem -- What is that?
    | ContextItem       loc.text = @name.text <+> head @types.text -- no parens because it is always a var
    --  range                    : Range
    --  name                     : Name   -- that is the class
    --  types                    : Types  -- in Haskell 98, this is only one type

SEM Constructor
    | Constructor       
    --  range                    : Range
    --  constructor              : Name
    --  types                    : AnnotatedTypes
    | Infix             loc.text = @leftType.text <+> @constructorOperator.text <+> @rightType.text
    --  range                    : Range
    --  leftType                 : AnnotatedType
    --  constructorOperator      : Name
    --  rightType                : AnnotatedType
    | Record            loc.text = @constructor.text <+> braces (commas @fieldDeclarations.text)
    --  range                    : Range
    --  constructor              : Name
    --  fieldDeclarations        : FieldDeclarations

-- This is in a record; what do we do with records?
SEM FieldDeclaration
    | FieldDeclaration      @lhs.typeDimension =
                                 fold (M.insert) @lhs.typeDimension
                                    [(n,t) | n <- @names.self, t <- @type.dimTypeInfo]
    --  range                    : Range
    --  names                    : Names
    --  type                     : AnnotatedType        

SEM AnnotatedType
    | AnnotatedType         @lhs.dimTypeInfo = @type.dimTypeInfo
    --  range                    : Range
    --  strict                   : Bool
    --  type                     : Type

-- ------------------------------------------------------------------------
-- -- Dimensions                                                         --
-- ------------------------------------------------------------------------

-- I think we will just have to skip this part, the normalization is done
-- in Normalize.ag


-- ------------------------------------------------------------------------
-- -- Expressions                                                        --
-- ------------------------------------------------------------------------

SEM MaybeExpression
    | Nothing
    | Just          loc.text = Just @expression.text
    --  expression               : Expression

SEM Expression
    | Hole               -- Nothing
    --  range                    : Range
    --  id                       : Integer
    | Literal            loc.dimExprInfo = Nothing
    --  range                    : Range
    --  literal                  : Literal
    | Constructor        loc.dimExprInfo = Nothing
    -- this is just something like "Nothing", so nothing
    --  range                    : Range
    --  name                     : Name
 
    | Variable           loc.dimExprInfo = M.lookup name variableDimension
    --  range                    : Range
    --  name                     : Name
    | Parenthesized      loc.dimExprInfo = @expression.dimExprInfo
    --  range                    : Range
    --  expression               : Expression
    | NormalApplication                  = unifyApplication @function.dimTypeInfo @arguments.dimTypeInfo
    
    -- check/unify with the dimensions get for the function
    --  range                    : Range
    --  function                 : Expression
    --  arguments                : Expressions
    | InfixApplication    -- same
    --  range                    : Range
    --  leftExpression           : MaybeExpression
    --  operator                 : Expression
    --  rightExpression          : MaybeExpression
    | If                 loc . thenDim = @thenExpression.dimTypeInfo
                             . elseDim = @elseExpression.dimTypeInfo
                         loc. (unifier, dimTypeInfo) = unify thenDim elseDim
    --  range                    : Range
    --  guardExpression          : Expression
    --  thenExpression           : Expression
    --  elseExpression           : Expression
    | Lambda             -- infer the unit of the expression and of the pattern
    --  range                    : Range
    --  patterns                 : Patterns
    --  expression               : Expression
    | Case                loc . (unifier, dimTypeInfo) = listUnify @alternatives.dimTypeInfo
    --  range                    : Range
    --  expression               : Expression
    --  alternatives             : Alternatives
    | Let                --in the expression which follows, add the declarations to the env but not for the rest
    --  range                    : Range
    --  declarations             : Declarations
    --  expression               : Expression
    | Do                 -- check statements one by one
    --  range                    : Range
    --  statements               : Statements
    | List               -- what do we want to do? Do we already check data structure ? Not that complicated?
    --  range                    : Range
    --  expressions              : Expressions
    | Tuple              loc . dimExprInfo =  Tuple @expressions.dimExprInfo
    --  range                    : Range
    --  expressions              : Expressions
    | Comprehension      --same question (the qualifiers are defining a subcontext)
    | Typed             loc . dimtype = @type.dimTypeInfo
                            . dimexpr = @expression.dimExprInfo
                        lhs . dimExprInfo = unify @dimtype @dimexpr
    --  range                    : Range
    --  expression               : Expression
    --  type                     : Type
    | Dimensioned        -- check expression and unit, should match
    --  range                    : Range
    --  expression               : Expression
    --  unit                     : Unit
    | RecordConstruction -- do we handle record? If so, check the unit and the one of the expression
    --  range                    : Range
    --  name                     : Name
    --  recordExpressionBindings : RecordExpressionBindings
    | RecordUpdate       -- same for the update
    --  range                    : Range
    --  expression               : Expression
    --  recordExpressionBindings : RecordExpressionBindingsconstructors
    | Enum               -- Maybe we could want dimensioned expression at this point, for example [1<Second>..]
                         -- even if we could write [n <Second> | n <- [1..]]
    --  range                    : Range
    --  from                     : Expression
    --  then                     : MaybeExpression
    --  to                       : MaybeExpression
    | Negate NegateFloat        loc.dimInfo = @expression.dimInfo
    --  range                    : Range
    --  expression               : Expression


---------------------------------------------------------------------------

-- Not sure of what it is 
SEM Statement
    | Expression          loc.text = @expression.text
    --  range                    : Range
    --  expression               : Expression
    | Let                 loc.text = text "let" <$> (indent 4 $ vcat @declarations.text)
    --  range                    : Range
    --  declarations             : Declarations
    | Generator           loc.text = @pattern.text <+> text "<-" <+> @expression.text
    --  range                    : Range
    --  pattern                  : Pattern
    --  expression               : Expression
    | Empty               loc.text = empty
    --  range                    : Range


-- same
SEM Qualifier
    | Guard               -- nothing
    --  range                    : Range
    --  guard                    : Expression -- type: Boolean
    | Let                 -- add the declarations 
    --  range                    : Range
    --  declarations             : Declarations
    | Generator           -- check the expression and attribute to the pattern the values
    --  range                    : Range
    --  pattern                  : Pattern
    --  expression               : Expression
    | Empty               -- Nothing

SEM Alternative
    | Hole Empty             -- Nothing
    | Alternative       -- the pattern having an associated type look at the right hand side 
    --  range                    : Range
    --  pattern                  : Pattern
    --  righthandside            : RightHandSide

SEM GuardedExpression
    | GuardedExpression loc.text = \assign -> text "|" <+> @guard.text <+> assign <+> @expression.text
    --  range                    : Range
    --  guard                    : Expression -- type: Boolean
    --  expression               : Expression


-------------------------------- What do we do with records? --------------------------------------------

SEM RecordExpressionBinding
    | RecordExpressionBinding loc.text = @name.text <+> text "=" <+> @expression.text -- ToDo: or _Binding?
    --  range                    : Range
    --  name                     : Name
    --  expression               : Expression

SEM RecordPatternBinding
    | RecordPatternBinding loc.text = @name.text <+> text "=" <+> @pattern.text -- ToDo: or _Binding?
    --  range                    : Range
    --  name                     : Name
    --  pattern                  : Pattern

---------------------------------------------------------------------------------------------------------

SEM FunctionBinding
    | Hole                  -- Nothing  
    | FunctionBinding       loc . functionDimType = 
                            righthandside.typeToDim = 
                            lefthandside.name = 
                            -- get a new environement with the variables,
                            -- undimensioned if not having a type already declared
                            lefthandside.patterns = 
    --  range                    : Range
    --  lefthandside             : LeftHandSide
    --  righthandside            : RightHandSide

ATTR LeftHandSide

-- the way we will proceed is the following:
-- We will only update the environment with those variables so
-- there is nothing else to return than the environment and the name of the function

-- not sure, maybe there is some checks there:
SEM LeftHandSide
    | Function         lhs.name = @name.self
                       lhs.dimExpr = M.lookup @name.self @lhs.variableToDim
                       patterns.variableToDim = 
                       -- we won't be in a specific case 
    --  range                    : Range
    --  name                     : Name
    --  patterns                 : Patterns
    | Infix            lhs.name = @operator.self
    --  range                    : Range
    --  leftPattern              : Pattern
    --  operator                 : Name
    --  rightPattern             : Pattern
    | Parenthesized    lhs.name = @lefthandside.name
    --  range                    : Range
    --  lefthandside             : LeftHandSide
    --  patterns                 : Patterns


SEM RightHandSide
    | expression           expression.variableToDim = M.union @where.variableToDim @lhs.variableToDim
                           @lhs.dimExprInfo = @expression.dimTypeInfo
    --  range                    : Range
    --  expression               : Expression
    --  where                    : MaybeDeclarations
    | Guarded               -- not sure of what GuardedExpression is
    --  range                    : Range
    --  guardedexpressions       : GuardedExpressions
    --  where                    : MaybeDeclarations

-- ------------------------------------------------------------------------
-- -- Patterns                                                           --
-- ------------------------------------------------------------------------

ATTR Pattern
    [ | | name : {Maybe Name}, dimtype : {UnitType} ]

SEM Pattern
    | Hole                  lhs.dimtype = Undimensioned
    --  range                    : Range
    --  id                       : String
    | Literal               lhs.dimtype = Undimensioned
    --  range                    : Range
    --  literal                  : Literal
    | Variable             lhs.name = @name.self
                           lhs.dimtype = Undimensioned
    --  range                    : Range          
    --  name                     : Name
    | Constructor          lhs.name = @name.self
                           lhs.dimtype = M.lookup @name.self @lhs.typeToDim
        range                    : Range
        name                     : Name
        patterns                 : Patterns
    | Parenthesized         lhs.name = @pattern.name
                               .dimtype = @pattern.dimtype
        range                    : Range
        pattern                  : Pattern
    | InfixConstructor      lhs.dimtype = List @constructorOperator.dimtype
                               .name = @constructorOperator.self
                            
        range                    : Range
        leftPattern              : Pattern
        constructorOperator      : Name
        rightPattern             : Pattern
    | List                  lhs.dimtype = List @patterns.dimtype
        range                    : Range
        patterns                 : Patterns
    | Tuple                 lhs.dimtype = Tuple @patterns.dimtype
        range                    : Range
        patterns                 : Patterns
    | Record
        range                    : Range
        name                     : Name
        recordPatternBindings    : RecordPatternBindings
    | Negate                lhs.name = Nothing
        range                    : Range
        literal                  : Literal -- only numbers allowed here
    | As                                  {- ??? -}
        range                    : Range
        name                     : Name
        pattern                  : Pattern
    | Wildcard
        range                    : Range
    | Irrefutable
        range                    : Range
        pattern                  : Pattern
    | Successor                    -- n+k patterns        
        range                    : Range
        name                     : Name
        literal                  : Literal