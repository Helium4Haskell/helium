-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
--
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Collect the following information:
--
--    1) dimension type constructors from a data type
--    2) dimension type synonyms
--    3) (value) constructors from a data type
--    4) fixity declarations
--    5) record declarations
--
-- Distribute the collected environments
--    6) value constructors
--    7) type constructors
--    8) type synonyms

-- Collect the following information:
--    9) type classes and their declarations
-------------------------------------------------------------------------------

-- WARNING, WE SHOULD NOT CONFUSE THE DIMENSION OF EXPRESSIONS
-- AND THE DIMENSION ASSOCIATED TO A TYPE CONSTRUCTOR
-- OR TO PARAMETERS OF A VALUE CONSTRUCTOR (WHICH IS IN FACT A FUNCTION)
-- /!\ I THINK WE SHOULD KEEP IT IN MIND !! AND CHECK|PROOF IF IT'S OK /!\
-- THE LINK IS THAT AN EXPRESSION OF TYPE T HAS AS A DIMENSION THE DIM OF T

-------------------------------------------------------------------------------
 -- 1) Collecting (data-) dimension type constructors

ATTR Body Declarations Declaration [ | collectDimTypeConstructors : { [(Name,(Int, Maybe [Name]))] } | ]

SEM Declaration
  | Data    lhs . collectDimTypeConstructors =
                (@simpletype.name, (length @simpletype.typevariables, Just @constructors.constructors) : @lhs.collectDimTypeConstructors)
  | Newtype lhs . collectDimTypeConstructors =
                (@simpletype.name, (length @simpletype.typevariables, Just @constructor.constructors) : @lhs.collectDimTypeConstructors)
  | Type -- maybe ?


-------------------------------------------------------------------------------
 -- 2) Collecting value dimension constructors

ATTR Body Declarations Declaration Constructors Constructor [ | collectValueDimConstructors : {[(Name, (Int,[UnitType] -> UnitType))]} | ]
ATTR Declaration Type Constructors Constructors [ | | numberParameter : Int ]



SEM Constructor
    | Constructor   lhs.collectValueDimConstructors = (@constructor.self,
                        (length (--number of parameters),
                        \utlist -> makeUnitTypeFromType
                        ))
        @constructor.self 
        @lhs.simpletype
        @types.self

    | Infix
    | Record

-------------------------------------------------------------------------------
 -- 3) Collecting dimension type synonyms

-- strongly inspired from Collect.ag

ATTR Body Declaration Declarations 
    [ | collectDimTypeSynonyms : { [(Name, (Int, [UnitType] -> UnitType))} ]

SEM Module | Module   body . collectDimTypeSynonyms = [] -- why ?


SEM Declaration
    | Type   lhs . collectDimTypeSynonyms = (@simpletype.name, @dimtypeSynonymInfo) : @lhs.collectDimTypeSynonyms
             loc . dimtypeSynonymInfo = (@simpletype.name,
                (length @simpletype.typevariables utlist, -- pretty sure I don't need it
                \utlist ->
                    makeUnitTypeFromType (zip @simpletype.typevariables tps) @type.self

                ))



-- 6) Distribution








{-
----------------------------------------------------------------------------------
SEM Declaration
    ----------------------------------- Problem 1 : Handle type structure -------------------------------

    | Type              @lhs.typeToDim = M.insert @simpletype.name @type.typeToDim @lhs.typeToDim
                        -- a bit more complicated because type Maybe a = a
                        -- but it is a type at the right and not something with constructors, which are expressions
    --  range                    : Range
    --  simpletype               : SimpleType
    --  type                     : Type

    -- a SimpleType declared by data or Newtype keywords can't have dimension (but it does declare constructors having dimensions)
    -- no constructors can have the same name
    -- So the important is not the type but the name of the constructor, we only store that
    -- so defaultly, unstored is undimensioned

    | Data              @lhs.typeToDim = M.insert @simpletype.name @type.typeToDim @lhs.typeToDim
    
                        -- The point is mainly adding  
                        -- Ca se fait mais Ã§a demande du travail.
    --  range                    : Range
    --  context                  : ContextItems
    --  simpletype               : SimpleType
    --  constructors             : Constructors
    --  derivings                : Names

    | Newtype           -- same
    --  range                    : Range
    --  context                  : ContextItems
    --  simpletype               : SimpleType
    --  constructor              : Constructor  -- has only one field, no strictness
    --  derivings                : Names


-- ------------------------------------------------------------------------
-- -- Types                                                              --
-- ------------------------------------------------------------------------

-- we need the dimension information

ATTR Types Type
    [ variableNameToNum : M.map Name Int | | typeVarToType : {[UnitType] -> UnitType}]

SEM Type
    | Application           @lhs.typeVarToType = \utlist ->
                                Arrow (@function.typesVarToType utlist) ([f utlist | f <- @arguments.typeVarToType ])
    --  range                    : Range
    --  prefix                   : Bool
    --  function                 : Type 
    --  arguments                : Types
    | Variable              @lhs.typeVarToType = \utlist ->
                                case M.lookup @lhs.variableNameToNum of
                                    Just varInt -> nth 
                                    Nothing -> [] -- not supposed to happen
    --  range                    : Range
    --  name                     : Name
    --  unit                     : MaybeUnit
    | Constructor              lhs.dimTypeInfo = Base @unit.self
                               lhs.typeToDim = M.insert @lhs.dimTypeInfo @lhs.typeToDim
    --  range                    : Range
    --  name                     : Name
    --  unit                     : MaybeUnit
    | Parenthesized            lhs.dimTypeInfo = @type.dimTypeInfo
                               lhs.typeToDim = @type.typeToDim
    --  range                    : Range
    --  type                     : Type
    | Qualified                lhs.dimTypeInfo = @type.dimTypeInfo
                               lhs.typeToDim = @type.typeToDim
    --  range                    : Range
    --  context                  : ContextItems
    --  type                     : Type

SEM SimpleType
    | SimpleType         lhs.dimTypeInfo = M.lookup @name.self @lhs.typeToDim
    --  name                     : Name
    --  typevariables            : Names

SEM ContextItem -- What is that?
    | ContextItem       loc.text = @name.text <+> head @types.text -- no parens because it is always a var
    --  range                    : Range
    --  name                     : Name   -- that is the class
    --  types                    : Types  -- in Haskell 98, this is only one type

SEM Constructor
    | Constructor       
    --  range                    : Range
    --  constructor              : Name
    --  types                    : AnnotatedTypes
    | Infix             
    --  range                    : Range
    --  leftType                 : AnnotatedType
    --  constructorOperator      : Name
    --  rightType                : AnnotatedType
    | Record            
    --  range                    : Range
    --  constructor              : Name
    --  fieldDeclarations        : FieldDeclarations

-- This is in a record; what do we do with records? : well, normal dim inference
SEM FieldDeclaration
    | FieldDeclaration      @lhs.typeToDim =
                                 fold (M.insert) @lhs.typeToDim
                                    [(n,t) | n <- @names.self, t <- @type.dimTypeInfo]
    --  range                    : Range
    --  names                    : Names
    --  type                     : AnnotatedType        

SEM AnnotatedType
    | AnnotatedType         @lhs.dimType = @type.dimTypeInfo
-}
{

makeUnitTypeFromType :: [(Name, UnitType)] -> Type -> UnitType
makeUnitTypeFromType nameMap = rec_
  where
        rec_ :: Type -> UnitType
        rec_ uhaType = case uhaType of
        -- I THINK I AM MAKING A MISTAKE THERE: WE SHOULD'NT HAVE ARROW
        --  ARROW and APP are differents:
        -- Arrow a b = App (Arrow) ([a,b])
        -- List a b = App (List) ([a,b])
             Type_Application _ _ fun args -> foldl Arrow (rec_ fun) (map rec_ args)
             Type_Variable _ name _        -> fromMaybe Undimensioned (lookup name nameMap)
             Type_Constructor _ name ut    -> ut
             Type_Parenthesized _ t        -> rec_ t
             Type_Qualified _ _ t          -> rec_ t
             Type_Forall{}                 -> internalError "TypeConversion.hs" "makeTpFromType" "universal types are currently not supported"
             Type_Exists{}                 -> internalError "TypeConversion.hs" "makeTpFromType" "existential types are currently not supported"

}