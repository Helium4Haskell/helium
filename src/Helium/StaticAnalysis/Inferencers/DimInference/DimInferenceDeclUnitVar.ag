-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
-- 
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Assigns unit variables. This allows to recover the unit information from the
-- output of the constraint solver/unification solver.
--
------------------------------------------------------------------------------

ATTR Body
  [ | deltaDeclUnique : Int | ]

SEM Module
  | Module
    body.deltaDeclUnique = 1000000000 -- 2 ^ 30

ATTR Declaration Declarations MaybeDeclarations
  Expression Expressions MaybeExpression
  Statements Statement Qualifiers Qualifier Alternatives Alternative
  GuardedExpressions GuardedExpression RecordExpressionBindings
  RecordExpressionBinding RecordPatternBindings RecordPatternBinding
  Constructor Constructors FieldDeclarations FieldDeclaration
  FunctionBindings FunctionBinding LeftHandSide RightHandSide
  Patterns Pattern [ | beta:Int | ]


SEM Declaration
  | FunctionBindings
    -- One unit variable for the function
    bindings.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | PatternBinding
    pattern.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | Data
    constructors.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    lhs.deltaDeclUnique = @constructors.deltaDeclUnique + 1
  | Instance
    where . deltaDeclUnique = @lhs.deltaDeclUnique + 1 + length(@typeVariables)

SEM Constructor
  | Record 
    fieldDeclarations . deltaDeclUnique = @lhs.deltaDeclUnique + 1
    lhs . deltaDeclUnique = @fieldDeclarations.deltaDeclUnique + 1

SEM FieldDeclaration
  | FieldDeclaration
    lhs . deltaDeclUnique = @lhs.deltaDeclUnique + (length @names.self)

SEM Expression
  | Lambda
    -- One unit variable for the function type
    patterns.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | Case
    -- One unit variable for the scrutinee, one type for the right hand side
    expression.deltaDeclUnique = @lhs.deltaDeclUnique + 2
  | InfixApplication
    leftExpression.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | Comprehension
    -- One unit variable for the elements of the list
    expression.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | Do
    -- One unit variable for the monad type (kind * -> *)
    -- One unit variable for the value in the monad (eg the 'a' in 'm a')
    statements.deltaDeclUnique = @lhs.deltaDeclUnique + 2
  | Variable
    lhs.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | Constructor
    lhs.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | RecordConstruction
    recordExpressionBindings.deltaDeclUnique = @lhs.deltaDeclUnique + 2
    loc.beta = TVar @lhs.deltaDeclUnique
    loc.betaFunc = TVar (@lhs.deltaDeclUnique + 1)
  | RecordUpdate
    expression.deltaDeclUnique = @lhs.deltaDeclUnique + 3
    loc.beta = TVar @lhs.deltaDeclUnique
    loc.betaFunc = TVar (@lhs.deltaDeclUnique + 1)
    loc.oldBeta = TVar (@lhs.deltaDeclUnique + 2)
  | List
    -- One unit variable for the elements of the list
    expressions.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | Enum
    -- One unit variable for the elements of the list
    from.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | Tuple
    expressions.deltaDeclUnique = @lhs.deltaDeclUnique + 1
  | Negate
    expression.deltaDeclUnique = @lhs.deltaDeclUnique + 1 

SEM Statement
  | Expression
    -- One unit variable for the value in the monad (eg the 'a' in 'IO a')
    expression.deltaDeclUnique = @lhs.deltaDeclUnique + 1

SEM RecordExpressionBinding
  | RecordExpressionBinding   
           lhs        . deltaDeclUnique = @expression.deltaDeclUnique + 1
           expression . deltaDeclUnique = @lhs.deltaDeclUnique + 1

ATTR Pattern          [ | | beta:Tp ]

SEM Pattern
  | Hole
    lhs.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | Literal
    lhs.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | Variable
    lhs.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | Constructor
    patterns.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | InfixConstructor
    leftPattern.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | List
    patterns.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | Tuple
    patterns.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | Record
    recordPatternBindings.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    lhs.deltaDeclUnique = @recordPatternBindings.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | Negate
    lhs.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | As
    pattern.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | Wildcard
    lhs.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | Irrefutable
    pattern.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

  | NegateFloat
    lhs.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

SEM RecordPatternBinding
  | RecordPatternBinding
    lhs.deltaDeclUnique = @lhs.deltaDeclUnique + 1
    loc.beta = TVar @lhs.deltaDeclUnique

{
chead [x] = x
chead x = error "Not a singleton"
}